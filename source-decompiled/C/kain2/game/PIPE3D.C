#include "THISDUST.H"
#include "PIPE3D.H"


// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_AspectAdjustMatrix(struct MATRIX *matrix /*$a0*/)
 // line 68, offset 0x8003a1f0
	/* begin block 1 */
		// Start line: 136
	/* end block 1 */
	// End Line: 137

	/* begin block 2 */
		// Start line: 139
	/* end block 2 */
	// End Line: 140

void PIPE3D_AspectAdjustMatrix(MATRIX *matrix)

{
  short in_v0;
  short in_a1;
  undefined4 in_a2;
  int in_hi;
  
  matrix->m[1] = in_v0 - in_a1;
  matrix->m[2] = (short)(in_hi >> 7) - (short)((int)in_a2 >> 0x1f);
  return;
}



// autogenerated function stub: 
// void /*$ra*/ PIPE3D_CalculateWCTransform(struct _CameraCore_Type *cameraCore /*$s2*/)
void PIPE3D_CalculateWCTransform(struct _CameraCore_Type *cameraCore)
{ // line 88, offset 0x8003a278
	/* begin block 1 */
		// Start line: 89
		// Start offset: 0x8003A278
		// Variables:
			struct MATRIX user_rotation; // stack offset -112
			struct MATRIX first; // stack offset -80
			struct MATRIX *cam_wcTrans; // $s3
			struct SVECTOR v0; // stack offset -48
			struct VECTOR v1; // stack offset -40
	/* end block 1 */
	// End offset: 0x8003A3CC
	// End Line: 133

	/* begin block 2 */
		// Start line: 195
	/* end block 2 */
	// End Line: 196

	/* begin block 3 */
		// Start line: 201
	/* end block 3 */
	// End Line: 202

}


// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_InvertTransform(struct MATRIX *target /*$s2*/, struct MATRIX *source /*$s1*/)
 // line 154, offset 0x8003a5f4
	/* begin block 1 */
		// Start line: 155
		// Start offset: 0x8003A5F4
		// Variables:
	// 		struct VECTOR sourceTrans; // stack offset -64
	// 		struct MATRIX normMat; // stack offset -48
	/* end block 1 */
	// End offset: 0x8003A63C
	// End Line: 168

	/* begin block 2 */
		// Start line: 359
	/* end block 2 */
	// End Line: 360

void PIPE3D_InvertTransform(MATRIX *target,MATRIX *source)

{
  int unaff_s1;
  int iStack00000018;
  
  iStack00000018 = -*(int *)(unaff_s1 + 0x1c);
  FUN_800bd5b4(target,source,target->t);
  return;
}



// decompiled code
// original method signature: 
// long /*$ra*/ PIPE3D_MatrixColumnLength(struct MATRIX *transform /*$a0*/, long column /*$a1*/)
 // line 174, offset 0x8003a688
	/* begin block 1 */
		// Start line: 175
		// Start offset: 0x8003A688
	/* end block 1 */
	// End offset: 0x8003A688
	// End Line: 175

	/* begin block 2 */
		// Start line: 405
	/* end block 2 */
	// End Line: 406

long PIPE3D_MatrixColumnLength(MATRIX *transform,long column)

{
  long lVar1;
  int in_v1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 *unaff_s0;
  undefined4 *unaff_s1;
  int iStack00000010;
  int iStack00000014;
  int iStack00000018;
  
  iStack00000010 = 0x1000000 / in_v1;
  iStack00000014 = FUN_8003a620();
  if (iStack00000014 != 0) {
    iStack00000014 = 0x1000000 / iStack00000014;
  }
  iStack00000018 = FUN_8003a620();
  if (iStack00000018 != 0) {
    iStack00000018 = 0x1000000 / iStack00000018;
  }
  uVar2 = unaff_s0[6];
  uVar3 = unaff_s0[7];
  unaff_s1[5] = unaff_s0[5];
  unaff_s1[6] = uVar2;
  unaff_s1[7] = uVar3;
  uVar2 = unaff_s0[1];
  uVar3 = unaff_s0[2];
  uVar4 = unaff_s0[3];
  *unaff_s1 = *unaff_s0;
  unaff_s1[1] = uVar2;
  unaff_s1[2] = uVar3;
  unaff_s1[3] = uVar4;
  unaff_s1[4] = unaff_s0[4];
  lVar1 = FUN_80078fec();
  return lVar1;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_NormalizeMatrix(struct MATRIX *target /*$s1*/, struct MATRIX *source /*$s0*/)
 // line 183, offset 0x8003a6c4
	/* begin block 1 */
		// Start line: 184
		// Start offset: 0x8003A6C4
		// Variables:
	// 		struct VECTOR scalevec; // stack offset -32
	// 		long scale; // $v1

		/* begin block 1.1 */
			// Start line: 196
			// Start offset: 0x8003A74C
			// TypeDefs:
		// 		struct PIPE3D_239fake tmm
		/* end block 1.1 */
		// End offset: 0x8003A74C
		// End Line: 196

		/* begin block 1.2 */
			// Start line: 196
			// Start offset: 0x8003A74C
			// TypeDefs:
		// 		struct PIPE3D_240fake cmm
		/* end block 1.2 */
		// End offset: 0x8003A74C
		// End Line: 196
	/* end block 1 */
	// End offset: 0x8003A74C
	// End Line: 200

	/* begin block 2 */
		// Start line: 426
	/* end block 2 */
	// End Line: 427

void PIPE3D_NormalizeMatrix(MATRIX *target,MATRIX *source)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *unaff_s0;
  undefined4 *unaff_s1;
  int iStack00000018;
  
  iStack00000018 = FUN_8003a620();
  if (iStack00000018 != 0) {
    iStack00000018 = 0x1000000 / iStack00000018;
  }
  uVar1 = unaff_s0[6];
  uVar2 = unaff_s0[7];
  unaff_s1[5] = unaff_s0[5];
  unaff_s1[6] = uVar1;
  unaff_s1[7] = uVar2;
  uVar1 = unaff_s0[1];
  uVar2 = unaff_s0[2];
  uVar3 = unaff_s0[3];
  *unaff_s1 = *unaff_s0;
  unaff_s1[1] = uVar1;
  unaff_s1[2] = uVar2;
  unaff_s1[3] = uVar3;
  unaff_s1[4] = unaff_s0[4];
  FUN_80078fec();
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_TransformVerticesToWorld(struct _Instance *instance /*stack 0*/, struct _SVector *poolVertex /*$s2*/, long *vtxSegment /*$s5*/, struct _Vector *Average /*$fp*/)
 // line 753, offset 0x8003a7b0
	/* begin block 1 */
		// Start line: 754
		// Start offset: 0x8003A7B0
		// Variables:
	// 		struct MATRIX *segMatrix; // $s1
	// 		struct _Model *model; // $s7
	// 		struct _MVertex *vertexList; // stack offset -48
	// 		long i; // $s3
	// 		struct _Segment *segment; // $v1
	// 		struct _SVector *orgPoolVertex; // stack offset -44
	// 		struct _SVector minV; // stack offset -64
	// 		struct _SVector maxV; // stack offset -56

		/* begin block 1.1 */
			// Start line: 773
			// Start offset: 0x8003A890
			// Variables:
		// 		struct _MVertex *firstVertex; // $s0
		// 		struct _MVertex *lastVertex; // $s6
		// 		struct _MVertex *modelVertex; // $s0
		/* end block 1.1 */
		// End offset: 0x8003A9DC
		// End Line: 815
	/* end block 1 */
	// End offset: 0x8003AAAC
	// End Line: 840

	/* begin block 2 */
		// Start line: 1506
	/* end block 2 */
	// End Line: 1507

void PIPE3D_TransformVerticesToWorld
               (_Instance *instance,_SVector *poolVertex,long *vtxSegment,_Vector *Average)

{
  undefined *puVar1;
  undefined *puVar2;
  int in_v1;
  short *psVar3;
  undefined4 *in_t0;
  short *unaff_s2;
  int iVar4;
  int iVar5;
  int *unaff_s7;
  int *unaff_s8;
  short sStack00000010;
  undefined4 uStack00000010;
  short sStack00000012;
  short sStack00000014;
  undefined4 uStack00000014;
  short sStack00000018;
  undefined *puStack00000018;
  short sStack0000001a;
  short sStack0000001c;
  undefined *puStack0000001c;
  int in_stack_00000050;
  
  puVar2 = PTR_DAT_800cead8;
  puVar1 = PTR_DAT_800cead4;
  uStack00000010 = *in_t0;
  uStack00000014 = in_t0[1];
  puStack00000018 = PTR_DAT_800cead4;
  puStack0000001c = PTR_DAT_800cead8;
  *unaff_s8 = 0;
  unaff_s8[1] = 0;
  unaff_s8[2] = 0;
  iVar4 = 0;
  if (0 < unaff_s7[6]) {
    iVar5 = in_v1 + 8;
    do {
      if (*(short *)(iVar5 + 2) != -1) {
        iVar4 = *(int *)(in_stack_00000050 + 0x40) + iVar4 * 0x20;
        FUN_800bce3c(iVar4);
                    /* WARNING: Subroutine does not return */
        FUN_800bce1c(iVar4);
      }
      iVar4 = iVar4 + 1;
      iVar5 = iVar5 + 0x18;
    } while (iVar4 < unaff_s7[6]);
  }
  if (*unaff_s7 != 0) {
    sStack00000018 = (short)puVar1;
    *unaff_s8 = (int)sStack00000018 + (int)sStack00000010 >> 1;
    sStack0000001a = (short)((uint)puVar1 >> 0x10);
    sStack00000012 = (short)((uint)uStack00000010 >> 0x10);
    unaff_s8[1] = (int)sStack0000001a + (int)sStack00000012 >> 1;
    sStack0000001c = (short)puVar2;
    unaff_s8[2] = (int)sStack0000001c + (int)sStack00000014 >> 1;
    iVar4 = 0;
    if (0 < *unaff_s7) {
      psVar3 = unaff_s2 + 2;
      do {
        *unaff_s2 = *unaff_s2 - *(short *)unaff_s8;
        iVar4 = iVar4 + 1;
        psVar3[-1] = psVar3[-1] - *(short *)(unaff_s8 + 1);
        unaff_s2 = unaff_s2 + 4;
        *psVar3 = *psVar3 - *(short *)(unaff_s8 + 2);
        psVar3 = psVar3 + 4;
      } while (iVar4 < *unaff_s7);
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_InstanceTransformAndDraw(struct _Instance *instance /*$s2*/, struct _CameraCore_Type *cameraCore /*$s1*/, struct _VertexPool *vertexPool /*$s0*/, struct _PrimPool *primPool /*$s7*/, unsigned long **ot /*stack 16*/, struct _Mirror *mirror /*stack 20*/)
 // line 856, offset 0x8003aadc
	/* begin block 1 */
		// Start line: 857
		// Start offset: 0x8003AADC
		// Variables:
	// 		struct Object *object; // $v0
	// 		struct _Model *model; // $s4
	// 		struct MATRIX *matrixPool; // $s3
	// 		struct MATRIX lm; // stack offset -80
	// 		long flags; // $s1

		/* begin block 1.1 */
			// Start line: 893
			// Start offset: 0x8003AB34
			// Variables:
		// 		struct _MVertex *vertexList; // $s0
		// 		struct _PVertex *poolVertex; // $s5
		// 		struct CVECTOR *vertexColor; // $s6
		// 		long spadOffset; // $v1
		// 		long spadFree; // $a1
		// 		long allocSize; // $a0

			/* begin block 1.1.1 */
				// Start line: 1036
				// Start offset: 0x8003AC5C
				// Variables:
			// 		long BackColorSave; // stack offset -44
			// 		long BlendStartSave; // $s0
			// 		int pval; // stack offset -48
			/* end block 1.1.1 */
			// End offset: 0x8003ADA4
			// End Line: 1076
		/* end block 1.1 */
		// End offset: 0x8003ADA4
		// End Line: 1081
	/* end block 1 */
	// End offset: 0x8003ADA4
	// End Line: 1082

	/* begin block 2 */
		// Start line: 1344
	/* end block 2 */
	// End Line: 1345

/* WARNING: Variable defined which should be unmapped: ot */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void PIPE3D_InstanceTransformAndDraw
               (_Instance *instance,_CameraCore_Type *cameraCore,_VertexPool *vertexPool,
               _PrimPool *primPool,ulong **ot,_Mirror *mirror)

{
  uint uVar1;
  undefined4 uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  undefined4 uVar7;
  int unaff_s2;
  int unaff_s3;
  int *unaff_s4;
  undefined2 *unaff_s5;
  int unaff_s7;
  undefined *puStack00000018;
  undefined4 uStack0000001c;
  int iStack00000040;
  undefined *puStack00000044;
  
  puStack00000018 = &DAT_00001080 + (int)unaff_s5;
  iVar4 = 0xe0;
  iVar5 = *unaff_s4;
  iVar6 = unaff_s4[1];
  iVar3 = 0x20;
  if (iVar5 * 2 < 0xe1) {
    unaff_s5 = &DAT_1f800080;
    iVar3 = iVar5 * 2 + 0x20;
    iVar4 = iVar5 * -2 + 0xe0;
  }
  if (iVar5 <= iVar4) {
    puStack00000018 = (undefined *)(iVar3 * 4 + 0x1f800000);
  }
  _modelFadeValue = FUN_800355d4();
  uStack0000001c = *(undefined4 *)(unaff_s2 + 0x264);
  uVar1 = FUN_80026d74(iVar6,unaff_s5);
  FUN_80035b30();
  FUN_800bf838(&stack0x00000020,unaff_s3 + (int)*(short *)(unaff_s2 + 0xee) * 0x20,&stack0x00000020)
  ;
  CdReady(&stack0x00000020);
  uVar2 = _depthQBlendStart;
  if ((uVar1 & 0x8000) != 0) {
    uVar1 = uVar1 & 0x7fff6fff;
  }
  if ((((uVar1 & 0xffffefff) == 0) || ((*(uint *)(*(int *)(unaff_s2 + 0x1c) + 0x2c) & 0x2000) != 0))
     && ((uint)(*(int *)(unaff_s7 + 4) + unaff_s4[4] * 0x30) < *(uint *)(unaff_s7 + 8))) {
    puStack00000044 = (undefined *)0x0;
    if ((*(uint *)(*(int *)(unaff_s2 + 0x1c) + 0x2c) & 0x1000) == 0) {
      FUN_800bce3c(level2SelectMenu.type);
                    /* WARNING: Subroutine does not return */
      FUN_800bce1c(level2SelectMenu.type);
    }
    iStack00000040 = getCopReg(2,8);
    uVar7 = 0;
    if (*(short *)(unaff_s2 + 0x152) != 0) {
      puStack00000044 = _depthQBackColor;
      _depthQBlendStart = _depthQFogStart;
      _depthQBackColor = &DAT_00707070;
      FUN_800bd394(&stack0x00000044,&depthQBackColor,iStack00000040,0x1000 - iStack00000040);
      if ((int)*(short *)(unaff_s2 + 0x152) < iStack00000040) {
        setCopReg(2,0x4000,iStack00000040);
        uVar7 = uVar2;
      }
      else {
        setCopReg(2,0x4000,(uint)*(ushort *)(unaff_s2 + 0x152));
        uVar7 = uVar2;
      }
    }
    if ((_modelFadeValue < 0xffe) &&
       (((*(uint *)(*(int *)(unaff_s2 + 0x1c) + 0x2c) & 0x1000) != 0 || (iStack00000040 < 0xffa))))
    {
      uVar2 = (*(code *)draw[1].dr_env.code[12])();
      *(undefined4 *)(unaff_s7 + 4) = uVar2;
    }
    if (*(short *)(unaff_s2 + 0x152) != 0) {
      _depthQBackColor = puStack00000044;
      _depthQBlendStart = uVar7;
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_InstanceListTransformAndDrawFunc(struct _StreamUnit *unit /*$a0*/, unsigned long **ot /*$s3*/, struct _CameraCore_Type *cameraCore /*$s1*/, struct _Instance *instance /*$s0*/)
 // line 1452, offset 0x8003add0
	/* begin block 1 */
		// Start line: 1453
		// Start offset: 0x8003ADD0
		// Variables:
	// 		struct _VertexPool *vertexPool; // $s4
	// 		struct _PrimPool *primPool; // $s2
	// 		struct VECTOR dpv[2]; // stack offset -72
	// 		long maxRad; // $a1
	// 		struct Level *level; // $s5
	// 		struct SVECTOR bsPos; // stack offset -40
	/* end block 1 */
	// End offset: 0x8003B0FC
	// End Line: 1586

	/* begin block 2 */
		// Start line: 2904
	/* end block 2 */
	// End Line: 2905

void PIPE3D_InstanceListTransformAndDrawFunc
               (_StreamUnit *unit,ulong **ot,_CameraCore_Type *cameraCore,_Instance *instance)

{
  undefined4 in_zero;
  undefined4 in_at;
  int iVar1;
  uint uVar2;
  int iVar3;
  int unaff_s0;
  int unaff_s1;
  undefined4 uStack00000014;
  int iStack00000018;
  int iStack0000001c;
  int iStack00000020;
  int iStack00000028;
  int iStack0000002c;
  undefined4 uStack00000030;
  undefined4 in_stack_00000038;
  undefined4 in_stack_0000003c;
  
  if ((unit->StreamUnitID == BmenuLines[2]._0_4_) || (iVar1 = FUN_8005b038(), iVar1 != 0)) {
    iVar3 = (int)*(short *)(*(int *)((int)*(short *)(unaff_s0 + 0x10a) * 4 +
                                    *(int *)(*(int *)(unaff_s0 + 0x1c) + 0xc)) + 0x24);
    setCopControlWord(2,0,*(undefined4 *)(unaff_s1 + 8));
    setCopControlWord(2,0x800,*(undefined4 *)(unaff_s1 + 0xc));
    setCopControlWord(2,0x1000,*(undefined4 *)(unaff_s1 + 0x10));
    setCopControlWord(2,0x1800,*(undefined4 *)(unaff_s1 + 0x14));
    setCopControlWord(2,0x2000,*(undefined4 *)(unaff_s1 + 0x18));
    setCopReg(2,in_zero,in_stack_00000038);
    setCopReg(2,in_at,in_stack_0000003c);
    copFunction(2,0x486012);
    iStack00000018 = getCopReg(2,0x19);
    iStack0000001c = getCopReg(2,0x1a);
    iStack00000020 = getCopReg(2,0x1b);
    iStack00000018 = iStack00000018 - *(int *)(unaff_s1 + 0x48);
    iVar1 = -iVar3;
    if ((iVar1 < iStack00000018) &&
       (((iStack00000018 < *(int *)(unaff_s1 + 100) + iVar3 &&
         (iVar1 < iStack0000001c - *(int *)(unaff_s1 + 0x4c))) &&
        (iVar1 < iStack00000020 - *(int *)(unaff_s1 + 0x50))))) {
      setCopControlWord(2,0,*(undefined4 *)(unaff_s1 + 0x28));
      setCopControlWord(2,0x800,*(undefined4 *)(unaff_s1 + 0x2c));
      setCopControlWord(2,0x1000,*(undefined4 *)(unaff_s1 + 0x30));
      setCopControlWord(2,0x1800,*(undefined4 *)(unaff_s1 + 0x34));
      setCopControlWord(2,0x2000,*(undefined4 *)(unaff_s1 + 0x38));
      setCopReg(2,in_zero,in_stack_00000038);
      setCopReg(2,in_at,in_stack_0000003c);
      copFunction(2,0x486012);
      iStack00000028 = getCopReg(2,0x19);
      iStack0000002c = getCopReg(2,0x1a);
      uStack00000030 = getCopReg(2,0x1b);
      if ((iVar1 < iStack00000028 - *(int *)(unaff_s1 + 0x54)) &&
         (iVar1 < iStack0000002c - *(int *)(unaff_s1 + 0x58))) {
        if ((*(uint *)(unaff_s0 + 0x14) & 0x80) == 0) {
          FUN_8003bbb4(*(undefined4 *)
                        (*(int *)((int)*(short *)(unaff_s0 + 0x10a) * 4 +
                                 *(int *)(*(int *)(unaff_s0 + 0x1c) + 0xc)) + 0x20),
                       draw[1].dr_env.code[4]);
          *(short *)(unaff_s0 + 0x6c) = *(short *)(unaff_s0 + 0x6c) + 1;
        }
        else {
          FUN_8003bbb4(*(undefined4 *)
                        (*(int *)((int)*(short *)(unaff_s0 + 0x10a) * 4 +
                                 *(int *)(*(int *)(unaff_s0 + 0x1c) + 0xc)) + 0x20),
                       (int)*(short *)(unaff_s0 + 0x6c));
        }
        FUN_80036460();
        if (((*(ushort *)(unaff_s0 + 0x11e) & 0xb) == 0) ||
           ((*(uint *)(unaff_s0 + 0x18) & 0x800000) != 0)) {
          uStack00000014 = 0;
          FUN_8003aa74();
        }
        else {
          uStack00000014 = 0;
          FUN_8003bdec();
        }
        if ((*(uint *)(unaff_s0 + 0x18) & 0x40) != 0) {
          FUN_800365dc(*(undefined4 *)(unaff_s1 + 0x60));
        }
        gameTrackerX.controlData[0][3] = gameTrackerX.controlData[0][3] + 1;
        uVar2 = *(uint *)(unaff_s0 + 0x14) | 0x200;
        goto LAB_8003b090;
      }
    }
  }
  uVar2 = *(uint *)(unaff_s0 + 0x14) & 0xfffffdff;
LAB_8003b090:
  *(uint *)(unaff_s0 + 0x14) = uVar2;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_InstanceListTransformAndDraw(struct _StreamUnit *unit /*$s3*/, struct GameTracker *gameTracker /*$a1*/, unsigned long **ot /*$s4*/, struct _CameraCore_Type *cameraCore /*$s5*/)
 // line 1588, offset 0x8003b120
	/* begin block 1 */
		// Start line: 1589
		// Start offset: 0x8003B120
		// Variables:
	// 		struct _Instance *instance; // $s0
	// 		int id; // $s2
	// 		struct _Instance *player; // $s1
	/* end block 1 */
	// End offset: 0x8003B1F0
	// End Line: 1603

	/* begin block 2 */
		// Start line: 2547
	/* end block 2 */
	// End Line: 2548

void PIPE3D_InstanceListTransformAndDraw
               (_StreamUnit *unit,GameTracker *gameTracker,ulong **ot,_CameraCore_Type *cameraCore)

{
  int unaff_s0;
  int unaff_s1;
  int unaff_s2;
  
  if (unaff_s0 != 0) {
    do {
      if (((((*(uint *)(unaff_s0 + 0x14) & 0x800) == 0) &&
           ((*(uint *)(unaff_s0 + 0x18) & 0x4000000) == 0)) &&
          (*(int *)(unaff_s0 + 0x38) == unaff_s2)) && (unaff_s0 != unaff_s1)) {
        FUN_8003ad68();
      }
      unaff_s0 = *(int *)(unaff_s0 + 8);
    } while (unaff_s0 != 0);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_TransformFromZAxis(struct MATRIX *transform /*$s0*/, struct _SVector *normal /*$s1*/)
 // line 1606, offset 0x8003b218
	/* begin block 1 */
		// Start line: 1607
		// Start offset: 0x8003B218
		// Variables:
	// 		struct _G2EulerAngles_Type ea1; // stack offset -40
	// 		struct _SVector xprod; // stack offset -32
	// 		struct _SVector yprod; // stack offset -24
	/* end block 1 */
	// End offset: 0x8003B3F4
	// End Line: 1645

	/* begin block 2 */
		// Start line: 2588
	/* end block 2 */
	// End Line: 2589

void PIPE3D_TransformFromZAxis(void)

{
  FUN_8003b38c();
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_CalcWorldToSplitPlaneTransform(struct MATRIX *wpTransform /*$s1*/, struct _SVector *normal /*$a1*/, struct _SVector *translation /*$s0*/)
 // line 1649, offset 0x8003b408
	/* begin block 1 */
		// Start line: 1650
		// Start offset: 0x8003B408
		// Variables:
	// 		struct _SVector svector; // stack offset -40
	// 		struct _Vector vector; // stack offset -32
	/* end block 1 */
	// End offset: 0x8003B408
	// End Line: 1650

	/* begin block 2 */
		// Start line: 2683
	/* end block 2 */
	// End Line: 2684

void PIPE3D_CalcWorldToSplitPlaneTransform
               (MATRIX *wpTransform,_SVector *normal,_SVector *translation)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 in_zero;
  undefined4 in_at;
  undefined4 in_t4;
  undefined4 in_t5;
  undefined4 in_t6;
  int unaff_s1;
  undefined4 in_stack_00000010;
  undefined4 in_stack_00000014;
  
  setCopControlWord(2,0x1000,in_t4);
  setCopControlWord(2,0x1800,in_t5);
  setCopControlWord(2,0x2000,in_t6);
  setCopReg(2,in_zero,in_stack_00000010);
  setCopReg(2,in_at,in_stack_00000014);
  copFunction(2,0x486012);
  uVar1 = getCopReg(2,0x19);
  uVar2 = getCopReg(2,0x1a);
  uVar3 = getCopReg(2,0x1b);
  *(undefined4 *)(unaff_s1 + 0x14) = uVar1;
  *(undefined4 *)(unaff_s1 + 0x18) = uVar2;
  *(undefined4 *)(unaff_s1 + 0x1c) = uVar3;
  return;
}



// decompiled code
// original method signature: 
// long /*$ra*/ PIPE3D_TransformAnimatedSplitInstanceVertices(struct _MVertex *vertexList /*stack 0*/, struct _PVertex *poolVertex /*$s4*/, struct _Model *model /*stack 8*/, struct MATRIX *wcTransform /*stack 12*/, struct MATRIX *matrixPool /*stack 16*/, struct _Mirror *mirror /*stack 20*/, struct MATRIX *lm /*stack 24*/, struct CVECTOR *vertexColor /*stack 28*/, struct CVECTOR *vertexSrcCol /*stack 32*/)
 // line 1688, offset 0x8003b4dc
	/* begin block 1 */
		// Start line: 1689
		// Start offset: 0x8003B4DC
		// Variables:
	// 		struct TransformAnimatedInstanceVerticesWork_t *w; // $s7
	// 		struct MATRIX *segMatrix; // $s2
	// 		long i; // stack offset -64
	// 		struct _Segment *segment; // stack offset -60
	// 		struct CVECTOR defaultRGBCD; // stack offset -80

		/* begin block 1.1 */
			// Start line: 1710
			// Start offset: 0x8003B56C
		/* end block 1.1 */
		// End offset: 0x8003B570
		// End Line: 1712

		/* begin block 1.2 */
			// Start line: 1719
			// Start offset: 0x8003B5A8
			// Variables:
		// 		struct _MVertex *firstVertex; // stack offset -56
		// 		struct _MVertex *lastVertex; // $fp
		// 		struct _MVertex *modelVertex; // $a2
		// 		struct _Normal *n0; // $t1
		// 		struct _Normal *n1; // $t2
		// 		struct _Normal *n2; // $t3
		// 		struct CVECTOR white; // stack offset -72
		// 		struct CVECTOR *c0; // $s1
		// 		struct CVECTOR *c1; // $s6
		// 		struct CVECTOR *c2; // $s5
		// 		long vtxcolflgs; // stack offset -52
		/* end block 1.2 */
		// End offset: 0x8003BA44
		// End Line: 1879
	/* end block 1 */
	// End offset: 0x8003BA6C
	// End Line: 1883

	/* begin block 2 */
		// Start line: 3376
	/* end block 2 */
	// End Line: 3377

/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

long PIPE3D_TransformAnimatedSplitInstanceVertices
               (_MVertex *vertexList,_PVertex *poolVertex,_Model *model,MATRIX *wcTransform,
               MATRIX *matrixPool,_Mirror *mirror,MATRIX *lm,CVECTOR *vertexColor,
               CVECTOR *vertexSrcCol)

{
  int iVar1;
  int unaff_s3;
  int unaff_s7;
  int in_stack_00000024;
  int iStack00000028;
  undefined4 uStack0000002c;
  int iStack00000030;
  int in_stack_00000060;
  int in_stack_00000068;
  undefined4 in_stack_0000006c;
  int in_stack_00000070;
  undefined4 in_stack_00000078;
  
  if (unaff_s3 != 0) {
    setCopReg(2,model,matrixPool);
  }
  if (_modelFadeValue == 0) {
    setCopReg(2,0x4000,0);
  }
  else {
    setCopReg(2,0x4000,_modelFadeValue);
  }
  vertexSrcCol = (CVECTOR *)0x0;
  if (0 < *(int *)(in_stack_00000068 + 0x18)) {
    iStack00000030 = unaff_s7 + 0x60;
    do {
      if (*(short *)(in_stack_00000024 + 10) != -1) {
        uStack0000002c = 0;
        iStack00000028 = in_stack_00000060 + (int)*(short *)(in_stack_00000024 + 8) * 8;
        iVar1 = in_stack_00000070 + (int)vertexSrcCol * 0x20;
        if (unaff_s3 != 0) {
          FUN_800bf838(in_stack_00000078,iVar1,unaff_s7 + 0x40);
          CdReady(unaff_s7 + 0x40);
        }
        FUN_800bfa58(in_stack_0000006c,iVar1);
        FUN_800bce3c();
                    /* WARNING: Subroutine does not return */
        FUN_800bce1c();
      }
      in_stack_00000024 = in_stack_00000024 + 0x18;
      vertexSrcCol = (CVECTOR *)&vertexSrcCol->g;
    } while ((int)vertexSrcCol < *(int *)(in_stack_00000068 + 0x18));
  }
  theCamera.savedCinematic[1].focusPoint._2_4_ = getCopReg(2,8);
  return 0;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_TransformSplitInstanceVertices(struct _MVertex *vertexList /*stack 0*/, struct _PVertex *pvertex /*$s2*/, struct _Model *model /*stack 8*/, struct MATRIX *wpTransform /*stack 12*/, struct MATRIX *matrixPool /*stack 16*/, struct _Mirror *mirror /*stack 20*/)
 // line 1891, offset 0x8003baa8
	/* begin block 1 */
		// Start line: 1892
		// Start offset: 0x8003BAA8
		// Variables:
	// 		struct MATRIX *spTransform; // $fp
	// 		struct _Vector *vector; // $s1
	// 		long i; // $s5
	// 		struct _Segment *segment; // $v1

		/* begin block 1.1 */
			// Start line: 1904
			// Start offset: 0x8003BB30
			// Variables:
		// 		struct _MVertex *firstVertex; // $s0
		// 		struct _MVertex *lastVertex; // $s4
		// 		struct _MVertex *modelVertex; // $s0
		/* end block 1.1 */
		// End offset: 0x8003BBC8
		// End Line: 1922
	/* end block 1 */
	// End offset: 0x8003BBEC
	// End Line: 1925

	/* begin block 2 */
		// Start line: 3663
	/* end block 2 */
	// End Line: 3664

void PIPE3D_TransformSplitInstanceVertices
               (_MVertex *vertexList,_PVertex *pvertex,_Model *model,MATRIX *wpTransform,
               MATRIX *matrixPool,_Mirror *mirror)

{
  int in_t0;
  int unaff_s5;
  int unaff_s6;
  int unaff_s7;
  int in_stack_00000040;
  undefined4 in_stack_00000044;
  
  do {
    if (*(short *)(unaff_s6 + *(int *)(in_t0 + 0x1c) + 10) != -1) {
      FUN_800bfa58(in_stack_00000044,unaff_s7);
      FUN_800bce3c();
                    /* WARNING: Subroutine does not return */
      FUN_800bce1c();
    }
    unaff_s7 = unaff_s7 + 0x20;
    unaff_s5 = unaff_s5 + 1;
    unaff_s6 = unaff_s6 + 0x18;
    in_t0 = in_stack_00000040;
  } while (unaff_s5 < *(int *)(in_stack_00000040 + 0x18));
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_AnimateTextures(struct AniTex *aniTextures /*$t1*/, long req_frame /*$a1*/)
 // line 1927, offset 0x8003bc1c
	/* begin block 1 */
		// Start line: 1928
		// Start offset: 0x8003BC1C
		// Variables:
	// 		struct AniTexInfo *ani_tex_info; // $t0
	// 		struct TextureMT3 *dest; // $a0
	// 		struct TextureMT3 *src; // $v1
	// 		long i; // $a3
	/* end block 1 */
	// End offset: 0x8003BCB4
	// End Line: 1947

	/* begin block 2 */
		// Start line: 3795
	/* end block 2 */
	// End Line: 3796

void PIPE3D_AnimateTextures(AniTex *aniTextures,long req_frame)

{
  TextureMT3 *in_v0;
  AniTex *pAVar1;
  AniTex *in_v1;
  uint *in_a2;
  int in_a3;
  AniTex **in_t0;
  int *in_t1;
  
  while( true ) {
    (aniTextures->aniTexInfo).texture = in_v0;
    in_t0 = in_t0 + 3;
    (aniTextures->aniTexInfo).numFrames = (in_v1->aniTexInfo).numFrames;
    in_a3 = in_a3 + 1;
    (aniTextures->aniTexInfo).speed = (in_v1->aniTexInfo).speed;
    if (*in_t1 <= in_a3) break;
    aniTextures = *in_t0;
    pAVar1 = aniTextures + ((uint)req_frame / in_a2[4]) % in_a2[3];
    in_v1 = pAVar1 + 1;
    aniTextures->numAniTextues = pAVar1[1].numAniTextues;
    in_v0 = pAVar1[1].aniTexInfo.texture;
    in_a2 = in_a2 + 3;
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_AnimateTerrainTextures(struct DrMoveAniTex *aniTextures /*$a0*/, long req_frame /*$a1*/, struct _PrimPool *primPool /*$a2*/, unsigned long **drawot /*$a3*/)
 // line 2020, offset 0x8003bcbc
	/* begin block 1 */
		// Start line: 2022
		// Start offset: 0x8003BCBC
		// Variables:
	// 		unsigned long *prim; // $t3
	// 		struct DrMoveAniTexDestInfo *dest; // $t1
	// 		struct DrMoveAniTexSrcInfo *src; // $t2
	// 		long i; // $t5
	// 		unsigned long **otl; // $a3
	/* end block 1 */
	// End offset: 0x8003BE4C
	// End Line: 2076

	/* begin block 2 */
		// Start line: 3999
	/* end block 2 */
	// End Line: 4000

	/* begin block 3 */
		// Start line: 4000
	/* end block 3 */
	// End Line: 4001

void PIPE3D_AnimateTerrainTextures
               (DrMoveAniTex *aniTextures,long req_frame,_PrimPool *primPool,ulong **drawot)

{
  undefined4 *in_t0;
  undefined4 *in_t1;
  int *piVar1;
  uint *in_t3;
  uint in_t4;
  int in_t5;
  int in_t6;
  uint in_t7;
  undefined4 in_t8;
  undefined4 in_t9;
  uint in_lo;
  
  while( true ) {
    piVar1 = in_t1 + (in_lo % in_t1[6]) * 2 + 8;
    if (*piVar1 != in_t1[4]) {
      in_t0[-4] = in_t9;
      in_t0[-3] = in_t8;
      in_t0[-2] = *piVar1;
      in_t0[-1] = *in_t1;
      *in_t0 = in_t1[1];
      *in_t3 = (uint)*drawot & in_t4 | in_t7;
      *drawot = (ulong *)((uint)in_t3 & in_t4);
      in_t0 = in_t0 + 6;
      in_t1[4] = *piVar1;
      in_t3 = in_t3 + 6;
      primPool->numPrims = primPool->numPrims + 1;
    }
    if (piVar1[1] != in_t1[5]) {
      in_t0[-4] = in_t9;
      in_t0[-3] = in_t8;
      in_t0[-2] = piVar1[1];
      in_t0[-1] = in_t1[2];
      *in_t0 = in_t1[3];
      *in_t3 = (uint)*drawot & in_t4 | in_t7;
      *drawot = (ulong *)((uint)in_t3 & in_t4);
      in_t0 = in_t0 + 6;
      in_t1[5] = piVar1[1];
      in_t3 = in_t3 + 6;
      primPool->numPrims = primPool->numPrims + 1;
    }
    in_t5 = in_t5 + 1;
    if (aniTextures->numAniTextues <= in_t5) break;
    in_t1 = *(undefined4 **)(in_t6 + 8);
    in_lo = (uint)req_frame / (uint)in_t1[7];
    in_t6 = in_t6 + 4;
  }
  primPool->nextPrim = in_t3;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_HalvePlaneInstanceTransformAndDraw(struct _Instance *instance /*$s2*/, struct MATRIX *wcTransform /*$s1*/, struct _VertexPool *vertexPool /*$s6*/, struct _PrimPool *primPool /*$s5*/, unsigned long **ot /*stack 16*/, struct _Mirror *mirror /*stack 20*/)
 // line 2103, offset 0x8003be54
	/* begin block 1 */
		// Start line: 2104
		// Start offset: 0x8003BE54
		// Variables:
	// 		struct Object *object; // $v1
	// 		struct _Model *model; // $s3
	// 		struct MATRIX *matrixPool; // $s4
	// 		struct MATRIX wpTransform; // stack offset -184
	// 		struct MATRIX pwTransform; // stack offset -152
	// 		struct MATRIX pcTransform; // stack offset -120
	// 		struct MATRIX lm; // stack offset -88
	// 		struct _MVertex *vertexList; // $s7
	// 		struct _SVector normalX; // stack offset -56
	// 		struct _SVector *normal; // $a1
	// 		struct _SVector translation; // stack offset -48
	/* end block 1 */
	// End offset: 0x8003C01C
	// End Line: 2172

	/* begin block 2 */
		// Start line: 4210
	/* end block 2 */
	// End Line: 4211

/* WARNING: Variable defined which should be unmapped: ot */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void PIPE3D_HalvePlaneInstanceTransformAndDraw
               (_Instance *instance,MATRIX *wcTransform,_VertexPool *vertexPool,_PrimPool *primPool,
               ulong **ot,_Mirror *mirror)

{
  short sVar1;
  short in_v0;
  ulong *puVar2;
  int unaff_s2;
  int unaff_s3;
  int unaff_s4;
  int unaff_s6;
  undefined *puStack00000018;
  undefined *puStack0000001c;
  undefined4 uStack00000020;
  short sStack000000b0;
  short sStack000000b2;
  short sStack000000b4;
  
  sVar1 = *(short *)(unaff_s2 + 0x11c);
  wcTransform->m[2] = sVar1;
  sStack000000b0 = -(short)((int)in_v0 * *(int *)(unaff_s2 + 0x120) >> 0xc);
  sStack000000b2 = -(short)((int)(short)instance * *(int *)(unaff_s2 + 0x120) >> 0xc);
  sStack000000b4 = -(short)((int)sVar1 * *(int *)(unaff_s2 + 0x120) >> 0xc);
  FUN_8003b3a0(&stack0x00000028,wcTransform,&stack0x000000b0);
  FUN_8003a58c(&stack0x00000048,&stack0x00000028);
  FUN_800bfa58();
  if (unaff_s4 != 0) {
    puStack00000018 = &stack0x00000088;
    FUN_80035b30();
    _modelFadeValue = FUN_800355d4();
    puStack0000001c = &DAT_00001080 + unaff_s6;
    uStack00000020 = *(undefined4 *)(unaff_s2 + 0x264);
    FUN_8003b474();
    if (primPool->nextPrim + *(int *)(unaff_s3 + 0x10) * 0xc < primPool->lastPrim) {
      draw_belowSplit = ZEXT14((*(ushort *)(unaff_s2 + 0x11e) & 2) != 0);
      puVar2 = (ulong *)FUN_80028390();
      primPool->nextPrim = puVar2;
    }
  }
  return;
}



// autogenerated function stub: 
// void /*$ra*/ PIPE3D_HalvePlaneGetRingPoints(struct _Instance *instance /*$a0*/, struct MATRIX *wcTransform /*$fp*/, struct _VertexPool *vertexPool /*$s6*/, struct _PrimPool *primPool /*$s7*/, unsigned long **ot /*stack 16*/, struct _FXHalvePlane *ring /*stack 20*/)
void PIPE3D_HalvePlaneGetRingPoints(struct _Instance *instance, struct MATRIX *wcTransform, struct _VertexPool *vertexPool, struct _PrimPool *primPool, unsigned long **ot, struct _FXHalvePlane *ring)
{ // line 2220, offset 0x8003c048
	/* begin block 1 */
		// Start line: 2221
		// Start offset: 0x8003C048
		// Variables:
			struct Object *object; // $v1
			struct _Model *model; // $s1
			struct MATRIX *matrixPool; // $s3
			struct MATRIX wpTransform; // stack offset -152
			struct MATRIX pwTransform; // stack offset -120
			struct MATRIX pcTransform; // stack offset -88
			struct _MVertex *vertexList; // $s4
			struct _PVertex *poolVertex; // $s5
			struct _SVector normalX; // stack offset -56
			struct _SVector *normal; // $a1
			struct _SVector translation; // stack offset -48
			struct _PlaneConstants *halvePlane; // $a0
	/* end block 1 */
	// End offset: 0x8003C1E8
	// End Line: 2278

	/* begin block 2 */
		// Start line: 4440
	/* end block 2 */
	// End Line: 4441

}


// decompiled code
// original method signature: 
// void /*$ra*/ PIPE3D_DoGlow(struct _Instance *instance /*$s2*/, struct MATRIX *wcTransform /*$a1*/, struct _VertexPool *vertexPool /*$a2*/, struct _PrimPool *primPool /*$s3*/, unsigned long **ot /*stack 16*/, struct _FXGlowEffect *glow /*stack 20*/)
 // line 2294, offset 0x8003c218
	/* begin block 1 */
		// Start line: 2295
		// Start offset: 0x8003C218
		// Variables:
	// 		long currentColorID; // $a2
	// 		long previousColorID; // $a1
	// 		long value; // $a0
	// 		long fade; // $a3
	// 		long fadeflag; // $s0

		/* begin block 1.1 */
			// Start line: 2325
			// Start offset: 0x8003C400
			// Variables:
		// 		long color; // stack offset -32

			/* begin block 1.1.1 */
				// Start line: 2370
				// Start offset: 0x8003C578
				// Variables:
			// 		long i; // $s0
			/* end block 1.1.1 */
			// End offset: 0x8003C5D4
			// End Line: 2380
		/* end block 1.1 */
		// End offset: 0x8003C5D4
		// End Line: 2381
	/* end block 1 */
	// End offset: 0x8003C5D4
	// End Line: 2382

	/* begin block 2 */
		// Start line: 4588
	/* end block 2 */
	// End Line: 4589

/* WARNING: Variable defined which should be unmapped: ot */

void PIPE3D_DoGlow(_Instance *instance,MATRIX *wcTransform,_VertexPool *vertexPool,
                  _PrimPool *primPool,ulong **ot,_FXGlowEffect *glow)

{
  bool bVar1;
  int in_v0;
  byte *pbVar2;
  int iVar3;
  int in_v1;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  int unaff_s1;
  int unaff_s2;
  int unaff_s3;
  uint uVar8;
  uint uVar9;
  int iStack00000018;
  uint uStack00000020;
  
  instance = (_Instance *)((int)instance + (in_v0 * 4 + in_v1) * -0x100);
  *(_Instance **)(unaff_s1 + 0x10) = instance;
  if (1 < (int)wcTransform) {
    uVar8 = (uint)instance % ((int)*(short *)(unaff_s1 + 0x1e) * (int)wcTransform);
    uVar9 = (uVar8 / (uint)(int)*(short *)(unaff_s1 + 0x1e)) % (uint)wcTransform;
    *(uint *)(unaff_s1 + 0x10) = uVar8;
    if (uVar9 == 0) {
      iVar3 = (int)wcTransform[-1].t + 0xb;
    }
    else {
      iVar3 = uVar9 - 1;
    }
    uVar8 = (*(uint *)(unaff_s1 + 0x10) % ((int)*(short *)(unaff_s1 + 0x1e) + 1U) << 0xc) /
            (uint)(int)*(short *)(unaff_s1 + 0x1e);
    if (0xfff < (int)uVar8) {
      uVar8 = 0;
    }
    setCopReg(2,0x4000,0x1000 - uVar8);
    pbVar2 = (byte *)(*(int *)(unaff_s1 + 0x14) + iVar3 * 4);
    setCopReg(2,0x4800,(uint)*pbVar2);
    setCopReg(2,0x5000,(uint)pbVar2[1]);
    setCopReg(2,0x5800,(uint)pbVar2[2]);
    copFunction(2,0x198003d);
    setCopReg(2,0x4000,uVar8);
    pbVar2 = (byte *)(*(int *)(unaff_s1 + 0x14) + uVar9 * 4);
    setCopReg(2,0x4800,(uint)*pbVar2);
    setCopReg(2,0x5000,(uint)pbVar2[1]);
    setCopReg(2,0x5800,(uint)pbVar2[2]);
    copFunction(2,0x1a8003e);
    uVar4 = getCopReg(2,0x4800);
    uVar5 = getCopReg(2,0x5000);
    uVar6 = getCopReg(2,0x5800);
    *(undefined *)(unaff_s1 + 0x18) = (char)uVar4;
    *(undefined *)(unaff_s1 + 0x19) = (char)uVar5;
    *(undefined *)(unaff_s1 + 0x1a) = (char)uVar6;
    uVar8 = *(uint *)(unaff_s1 + 0x18) & 0xffffff;
    *(uint *)(unaff_s1 + 0x18) = uVar8;
    *(uint *)(unaff_s1 + 0x18) =
         uVar8 | *(uint *)(iVar3 * 4 + *(int *)(unaff_s1 + 0x14)) & 0xff000000;
  }
  if ((*(int *)(unaff_s2 + 0x40) != 0) && (*(int *)(unaff_s2 + 0x44) != 0)) {
    bVar1 = false;
    if (((int)*(short *)(unaff_s2 + 0xec) == 0) && ((short)loadStatus.decompressLen == 1000)) {
      iVar3 = (int)*(short *)(unaff_s1 + 0xe);
      if (-1 < iVar3) {
        if (*(uint *)(unaff_s1 + 0x10) < (uint)(int)*(short *)(unaff_s1 + 0x28)) {
          primPool = (_PrimPool *)
                     ((*(uint *)(unaff_s1 + 0x10) << 0xc) / (uint)(int)*(short *)(unaff_s1 + 0x28));
          bVar1 = true;
        }
        else {
          if (iVar3 < (int)*(short *)(unaff_s1 + 0x2a)) {
            bVar1 = true;
            primPool = (_PrimPool *)((iVar3 << 0xc) / (int)*(short *)(unaff_s1 + 0x2a));
          }
        }
      }
    }
    else {
      bVar1 = true;
      if ((short)loadStatus.decompressLen == 1000) {
        primPool = (_PrimPool *)(0x1000 - (int)*(short *)(unaff_s2 + 0xec));
      }
      else {
        iVar3 = FUN_800355d4();
        primPool = (_PrimPool *)(0x1000 - iVar3);
      }
    }
    if (bVar1) {
      setCopReg(2,0x4000,primPool);
      setCopReg(2,0x4800,(uint)*(byte *)(unaff_s1 + 0x18));
      setCopReg(2,0x5000,(uint)*(byte *)(unaff_s1 + 0x19));
      setCopReg(2,0x5800,(uint)*(byte *)(unaff_s1 + 0x1a));
      copFunction(2,0x198003d);
      uVar4 = getCopReg(2,0x4800);
      uVar5 = getCopReg(2,0x5000);
      uVar6 = getCopReg(2,0x5800);
      uStack00000020 = (uint)CONCAT12((char)uVar6,CONCAT11((char)uVar5,(char)uVar4));
      if ((*(uint *)(unaff_s1 + 0x18) & 0x1000000) != 0) {
        uStack00000020 = uStack00000020 | 0x1000000;
      }
    }
    else {
      uStack00000020 = *(uint *)(unaff_s1 + 0x18);
    }
    if (*(char *)(unaff_s1 + 0x24) == '\x01') {
      iStack00000018 = (int)*(short *)(unaff_s1 + 0x22);
      uVar4 = FUN_8002bba8();
      *(undefined4 *)(unaff_s3 + 4) = uVar4;
    }
    else {
      iVar7 = (int)*(short *)(unaff_s1 + 0x26);
      iVar3 = iVar7 + (uint)*(byte *)(unaff_s1 + 0x24);
      while (iVar7 < iVar3 + -1) {
        iStack00000018 = (int)*(short *)(unaff_s1 + 0x22);
        uVar4 = FUN_8002ba3c();
        *(undefined4 *)(unaff_s3 + 4) = uVar4;
        iVar7 = iVar7 + 1;
        iVar3 = (int)*(short *)(unaff_s1 + 0x26) + (uint)*(byte *)(unaff_s1 + 0x24);
      }
    }
  }
  return;
}



// decompiled code
// original method signature: 
// long /*$ra*/ PIPE3D_Segment2ScreenPt(struct _Instance *instance /*$a0*/, struct MATRIX *wcTransform /*$a1*/, int segIndex /*$a2*/, struct _Position *pos /*$s0*/)
 // line 2388, offset 0x8003c5f4
	/* begin block 1 */
		// Start line: 2389
		// Start offset: 0x8003C5F4
		// Variables:
	// 		struct MATRIX scTransform; // stack offset -56
	// 		struct _Position vOrigin; // stack offset -24
	// 		long face_z; // stack offset -16
	/* end block 1 */
	// End offset: 0x8003C5F4
	// End Line: 2389

	/* begin block 2 */
		// Start line: 4816
	/* end block 2 */
	// End Line: 4817

long PIPE3D_Segment2ScreenPt(_Instance *instance,MATRIX *wcTransform,int segIndex,_Position *pos)

{
  int in_stack_00000038;
  
  return (in_stack_00000038 >> 2) + -0x14;
}





