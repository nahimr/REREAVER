#include "THISDUST.H"
#include "AADLIB.H"


// decompiled code
// original method signature: 
// unsigned long /*$ra*/ aadGetMemorySize(struct AadInitAttr *attributes /*$a0*/)
 // line 40, offset 0x800514d4
	/* begin block 1 */
		// Start line: 80
	/* end block 1 */
	// End Line: 81

	/* begin block 2 */
		// Start line: 81
	/* end block 2 */
	// End Line: 82

ulong aadGetMemorySize(AadInitAttr *attributes)

{
                    /* WARNING: Subroutine does not return */
  FUN_800bcdac(attributes,0,&DAT_00001009);
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadInit(struct AadInitAttr *attributes /*$s1*/, unsigned char *memoryPtr /*$s0*/)
 // line 46, offset 0x800514f8
	/* begin block 1 */
		// Start line: 47
		// Start offset: 0x800514F8
		// Variables:
	// 		struct _AadSequenceSlot *slot; // $v1
	// 		unsigned long size; // $v0
	// 		int slotNumber; // $a2
	// 		int i; // $a1
	/* end block 1 */
	// End offset: 0x8005178C
	// End Line: 183

	/* begin block 2 */
		// Start line: 92
	/* end block 2 */
	// End Line: 93

int aadInit(AadInitAttr *attributes,uchar *memoryPtr)

{
  AadMemoryStruct *pAVar1;
  int in_v0;
  _func_44 *in_v1;
  int unaff_s1;
  
  pAVar1 = aadMem;
  if ((in_v0 != 0) && (*(int *)(unaff_s1 + 0x10) != 0)) {
    aadMem->nonBlockLoadProc = in_v1;
    pAVar1->nonBlockBufferedLoadProc = *(_func_45 **)(unaff_s1 + 0xc);
    pAVar1->memoryMallocProc = *(_func_46 **)(unaff_s1 + 0x10);
                    /* WARNING: Subroutine does not return */
    pAVar1->memoryFreeProc = *(_func_47 **)(unaff_s1 + 0x14);
    FUN_800bcdac(pAVar1->sfxToneMasterList,0xff,0x200);
  }
  return (int)&DAT_00001008;
}



// autogenerated function stub: 
// void /*$ra*/ aadInstallUpdateFunc(TDRFuncPtr_aadInstallUpdateFunc0updateFuncPtr updateFuncPtr /*$s0*/, int hblanksPerUpdate /*$s1*/)
void aadInstallUpdateFunc(TDRFuncPtr_aadInstallUpdateFunc0updateFuncPtr updateFuncPtr, int hblanksPerUpdate)
{ // line 186, offset 0x800517a0
	/* begin block 1 */
		// Start line: 495
	/* end block 1 */
	// End Line: 496

}


// decompiled code
// original method signature: 
// void /*$ra*/ aadInitVolume()
 // line 199, offset 0x8005181c
	/* begin block 1 */
		// Start line: 521
	/* end block 1 */
	// End Line: 522

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadInitVolume(void)

{
  int in_v0;
  undefined4 in_a0;
  undefined4 in_a1;
  undefined4 in_a2;
  
  *(undefined4 *)(in_v0 + 0x10) = in_a1;
  *(undefined4 *)(in_v0 + 0x14) = in_a0;
  *(undefined4 *)(in_v0 + 0x18) = in_a2;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadSetMasterVolume(int volume /*$a0*/)
 // line 210, offset 0x80051850
	/* begin block 1 */
		// Start line: 547
	/* end block 1 */
	// End Line: 548

void aadSetMasterVolume(int volume)

{
  _func_36 **pp_Var1;
  int in_v0;
  int iVar2;
  
  iVar2 = 0;
  *(int *)(in_v0 + 0x20) = volume;
  if (0 < *(int *)(in_v0 + 4)) {
    do {
      pp_Var1 = aadMem->sequenceSlots + iVar2;
      iVar2 = iVar2 + 1;
      FUN_8005529c(*pp_Var1);
    } while (iVar2 < aadMem->numSlots);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadStartMasterVolumeFade(int targetVolume /*$a0*/, int volumeStep /*$a1*/, TDRFuncPtr_aadStartMasterVolumeFade2fadeCompleteCallback fadeCompleteCallback /*$a2*/)
 // line 219, offset 0x80051880
	/* begin block 1 */
		// Start line: 568
	/* end block 1 */
	// End Line: 569

	/* begin block 2 */
		// Start line: 570
	/* end block 2 */
	// End Line: 571

void aadStartMasterVolumeFade
               (int targetVolume,int volumeStep,
               TDRFuncPtr_aadStartMasterVolumeFade2fadeCompleteCallback fadeCompleteCallback)

{
  _func_36 **pp_Var1;
  AadMemoryStruct *in_v0;
  int unaff_s0;
  
  while (unaff_s0 < in_v0->numSlots) {
    pp_Var1 = aadMem->sequenceSlots + unaff_s0;
    unaff_s0 = unaff_s0 + 1;
    FUN_8005529c(*pp_Var1);
    in_v0 = aadMem;
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadSetSfxMasterVolume(int volume /*$a0*/)
 // line 229, offset 0x80051898
	/* begin block 1 */
		// Start line: 588
	/* end block 1 */
	// End Line: 589

	/* begin block 2 */
		// Start line: 590
	/* end block 2 */
	// End Line: 591

void aadSetSfxMasterVolume(int volume)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadSetMusicMasterVolume(int volume /*$a0*/)
 // line 237, offset 0x800518a8
	/* begin block 1 */
		// Start line: 238
		// Start offset: 0x800518A8
		// Variables:
	// 		int slotNumber; // $s0
	/* end block 1 */
	// End offset: 0x800518FC
	// End Line: 247

	/* begin block 2 */
		// Start line: 604
	/* end block 2 */
	// End Line: 605

	/* begin block 3 */
		// Start line: 608
	/* end block 3 */
	// End Line: 609

void aadSetMusicMasterVolume(int volume)

{
  int in_v0;
  undefined4 in_a1;
  undefined4 in_a2;
  
  *(undefined4 *)(in_v0 + 0x28) = in_a1;
  *(int *)(in_v0 + 0x2c) = volume;
  *(undefined4 *)(in_v0 + 0x30) = in_a2;
  return;
}



// autogenerated function stub: 
// void /*$ra*/ aadStartMusicMasterVolFade(int targetVolume /*$a0*/, int volumeStep /*$a1*/, TDRFuncPtr_aadStartMusicMasterVolFade2fadeCompleteCallback fadeCompleteCallback /*$a2*/)
void aadStartMusicMasterVolFade(int targetVolume, int volumeStep, TDRFuncPtr_aadStartMusicMasterVolFade2fadeCompleteCallback fadeCompleteCallback)
{ // line 249, offset 0x8005190c
	/* begin block 1 */
		// Start line: 633
	/* end block 1 */
	// End Line: 634

	/* begin block 2 */
		// Start line: 635
	/* end block 2 */
	// End Line: 636

}


// decompiled code
// original method signature: 
// void /*$ra*/ aadShutdown()
 // line 285, offset 0x80051924
	/* begin block 1 */
		// Start line: 570
	/* end block 1 */
	// End Line: 571

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadShutdown(void)

{
  FUN_800c0264();
  FUN_800c05e4();
  aadMem = (AadMemoryStruct *)0x0;
  return;
}



// decompiled code
// original method signature: 
// long /*$ra*/ aadSlotUpdateWrapper()
 // line 321, offset 0x800519ac
	/* begin block 1 */
		// Start line: 322
		// Start offset: 0x800519AC
		// Variables:
	// 		unsigned long curGp; // $s0
	/* end block 1 */
	// End offset: 0x800519AC
	// End Line: 322

	/* begin block 2 */
		// Start line: 745
	/* end block 2 */
	// End Line: 746

/* WARNING: Unknown calling convention yet parameter storage is locked */

long aadSlotUpdateWrapper(void)

{
  char cVar1;
  byte bVar2;
  ushort uVar3;
  AadSfxSlot *pAVar4;
  AadMemoryStruct *pAVar5;
  ulong in_v0;
  ulong uVar6;
  int iVar7;
  int iVar8;
  uchar uVar9;
  _func_12 *p_Var10;
  int in_a0;
  uint *puVar11;
  uint uVar12;
  bool bVar13;
  uint uVar14;
  int iVar15;
  uint *puVar16;
  uint *puVar17;
  uint *puVar18;
  
  if (in_a0 != 0) {
    if ((*(uint *)(in_a0 + 0x24) & 2) == 0) {
      FUN_800c01d8(in_a0 + 0x47c);
      pAVar5 = aadMem;
      iVar15 = 0;
      uVar14 = 1;
      do {
        cVar1 = pAVar5->voiceStatus[iVar15];
        if (cVar1 == '\x03') {
          uVar6 = pAVar5->voiceKeyOffRequest | uVar14;
LAB_80051a34:
          pAVar5->voiceKeyOffRequest = uVar6;
        }
        else {
          if (((pAVar5->voiceKeyOffRequest & uVar14) != 0) && ((cVar1 == '\0' || (cVar1 == '\x02')))
             ) {
            uVar6 = pAVar5->voiceKeyOffRequest & ~uVar14;
            goto LAB_80051a34;
          }
        }
        iVar15 = iVar15 + 1;
        uVar14 = uVar14 << 1;
      } while (iVar15 < 0x18);
      if (((aadMem->flags & 4U) == 0) && (iVar15 = 0, 0 < aadMem->numSlots)) {
        iVar7 = 0;
        do {
          puVar17 = *(uint **)((int)aadMem->sequenceSlots + iVar7);
          if (((*(ushort *)(puVar17 + 0x150) & 1) != 0) && ((*(byte *)(puVar17 + 0x154) & 1) == 0))
          {
            *puVar17 = *puVar17 + (uint)*(ushort *)(puVar17 + 4);
            uVar14 = puVar17[1] + puVar17[3];
            puVar17[1] = uVar14;
            if (puVar17[2] <= uVar14) {
              puVar17[1] = uVar14 - puVar17[2];
              *puVar17 = *puVar17 + 1;
            }
            do {
              iVar7 = 0;
              puVar16 = puVar17;
              puVar18 = puVar17;
              do {
                if (puVar18[0xd2] == 0) break;
                bVar2 = *(byte *)(puVar16 + 0xce);
                while ((bVar2 < 3 && (iVar8 = FUN_80054910(puVar17,iVar7), iVar8 == 0))) {
                  bVar2 = *(byte *)(puVar16 + 0xce);
                }
                puVar16 = (uint *)((int)puVar16 + 1);
                iVar7 = iVar7 + 1;
                puVar18 = puVar18 + 1;
              } while (iVar7 < 0x10);
              bVar13 = true;
              iVar7 = 0;
              iVar8 = 0;
              puVar16 = puVar17;
              puVar18 = puVar17;
              do {
                if (puVar16[0xd2] == 0) break;
                cVar1 = *(char *)(puVar18 + 0xce);
                while (cVar1 != '\0') {
                  puVar11 = (uint *)((int)puVar17 +
                                    iVar8 + (uint)*(byte *)(puVar18 + 0xca) * 0xc0 + 0x18);
                  uVar12 = *puVar11;
                  uVar14 = uVar12 + puVar16[0xe2];
                  if ((*puVar17 < uVar14) || (1000000 < uVar12)) break;
                  puVar16[0xe2] = uVar14;
                  cVar1 = *(char *)(puVar18 + 0xca);
                  *(char *)(puVar18 + 0xca) = cVar1 + '\x01';
                  *(char *)(puVar18 + 0xce) = *(char *)(puVar18 + 0xce) + -1;
                  if ((char)(cVar1 + '\x01') == '\x04') {
                    *(undefined *)(puVar18 + 0xca) = 0;
                  }
                  FUN_80054b04(puVar11,puVar17);
                  cVar1 = *(char *)(puVar18 + 0xce);
                  bVar13 = false;
                }
                puVar16 = puVar16 + 1;
                iVar8 = iVar8 + 0xc;
                iVar7 = iVar7 + 1;
                puVar18 = (uint *)((int)puVar18 + 1);
              } while (iVar7 < 0x10);
            } while (!bVar13);
          }
          iVar15 = iVar15 + 1;
          iVar7 = iVar15 * 4;
        } while (iVar15 < aadMem->numSlots);
      }
      uVar3 = (aadMem->sfxSlot).commandsInQueue;
      while (uVar3 != 0) {
        FUN_80056ea8((aadMem->sfxSlot).commandQueue + (uint)(aadMem->sfxSlot).commandOut);
        pAVar5 = aadMem;
        pAVar4 = &aadMem->sfxSlot;
        uVar9 = (aadMem->sfxSlot).commandOut + '\x01';
        (aadMem->sfxSlot).commandOut = uVar9;
        (pAVar5->sfxSlot).commandsInQueue = pAVar4->commandsInQueue - 1;
        if (uVar9 == ' ') {
          (aadMem->sfxSlot).commandOut = '\0';
        }
        uVar3 = (aadMem->sfxSlot).commandsInQueue;
      }
      uVar14 = aadMem->voiceKeyOffRequest & ~aadMem->voiceKeyOnRequest;
      aadMem->voiceKeyOffRequest = uVar14;
      if (uVar14 != 0) {
        FUN_800c0018(0);
      }
      FUN_800c04b4(1,aadMem->voiceReverbRequest);
      FUN_800c04b4(0,~aadMem->voiceReverbRequest);
      if (aadMem->voiceKeyOnRequest != 0) {
        FUN_800c0018(1);
        aadMem->voiceKeyOnRequest = 0;
      }
    }
    iVar15 = (aadMem->masterVolFader).volumeStep;
    bVar13 = false;
    if (iVar15 != 0) {
      iVar7 = aadMem->masterVolume + iVar15;
      if (iVar15 < 0) {
        bVar13 = iVar7 < (aadMem->masterVolFader).targetVolume;
      }
      else {
        if ((aadMem->masterVolFader).targetVolume < iVar7) {
          bVar13 = true;
        }
      }
      if (bVar13) {
        iVar7 = (aadMem->masterVolFader).targetVolume;
        p_Var10 = (aadMem->masterVolFader).fadeCompleteCallback;
        (aadMem->masterVolFader).volumeStep = 0;
        if (p_Var10 != (_func_12 *)0x0) {
          (*p_Var10)();
        }
      }
      FUN_800517e8(iVar7);
    }
    iVar15 = (aadMem->musicMasterVolFader).volumeStep;
    if ((iVar15 != 0) && (bVar13 = false, (aadMem->updateCounter & 1) == 0)) {
      iVar7 = aadMem->musicMasterVol + iVar15;
      if (iVar15 < 0) {
        bVar13 = iVar7 <= (aadMem->musicMasterVolFader).targetVolume;
      }
      else {
        if ((aadMem->musicMasterVolFader).targetVolume <= iVar7) {
          bVar13 = true;
        }
      }
      if (bVar13) {
        iVar7 = (aadMem->musicMasterVolFader).targetVolume;
        p_Var10 = (aadMem->musicMasterVolFader).fadeCompleteCallback;
        (aadMem->musicMasterVolFader).volumeStep = 0;
        if (p_Var10 != (_func_12 *)0x0) {
          (*p_Var10)();
        }
      }
      FUN_80051840(iVar7);
    }
    in_v0 = aadMem->updateCounter + 1;
    aadMem->updateCounter = in_v0;
  }
  return in_v0;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadSlotUpdate()
 // line 338, offset 0x800519f0
	/* begin block 1 */
		// Start line: 339
		// Start offset: 0x800519F0
		// Variables:
	// 		struct _AadSequenceSlot *slot; // $s2
	// 		struct AadSeqEvent *seqEventPtr; // $a0
	// 		int slotNumber; // $fp
	// 		int i; // $a3
	// 		int fadeComplete; // $v1
	// 		int track; // $s3
	// 		int newVol; // $s0
	// 		int slotDone; // $a2

		/* begin block 1.1 */
			// Start line: 354
			// Start offset: 0x80051A38
			// Variables:
		// 		unsigned long vmask; // $a2
		/* end block 1.1 */
		// End offset: 0x80051AB0
		// End Line: 369
	/* end block 1 */
	// End offset: 0x80051F08
	// End Line: 592

	/* begin block 2 */
		// Start line: 780
	/* end block 2 */
	// End Line: 781

	/* begin block 3 */
		// Start line: 789
	/* end block 3 */
	// End Line: 790

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadSlotUpdate(void)

{
  byte bVar1;
  char cVar2;
  ushort uVar3;
  AadSfxSlot *pAVar4;
  AadMemoryStruct *pAVar5;
  int in_v0;
  uint uVar6;
  int iVar7;
  int iVar8;
  uchar uVar9;
  _func_12 *p_Var10;
  uint *puVar11;
  int in_a1;
  uint uVar12;
  bool bVar13;
  uint in_a2;
  int in_a3;
  uint in_t0;
  uint in_t1;
  uint *puVar14;
  uint *puVar15;
  uint *puVar16;
  int iVar17;
  
  do {
    bVar1 = *(byte *)(in_v0 + 0x47c);
    if ((uint)bVar1 == in_t1) {
      uVar6 = *(uint *)(in_a1 + 0x4c4) | in_a2;
LAB_80051a34:
      *(uint *)(in_a1 + 0x4c4) = uVar6;
    }
    else {
      if (((*(uint *)(in_a1 + 0x4c4) & in_a2) != 0) && ((bVar1 == 0 || ((uint)bVar1 == in_t0)))) {
        uVar6 = *(uint *)(in_a1 + 0x4c4) & ~in_a2;
        goto LAB_80051a34;
      }
    }
    in_a3 = in_a3 + 1;
    in_a2 = in_a2 << 1;
    if (0x17 < in_a3) {
      if (((aadMem->flags & 4U) == 0) && (iVar17 = 0, 0 < aadMem->numSlots)) {
        iVar7 = 0;
        do {
          puVar15 = *(uint **)((int)aadMem->sequenceSlots + iVar7);
          if (((*(ushort *)(puVar15 + 0x150) & 1) != 0) && ((*(byte *)(puVar15 + 0x154) & 1) == 0))
          {
            *puVar15 = *puVar15 + (uint)*(ushort *)(puVar15 + 4);
            uVar6 = puVar15[1] + puVar15[3];
            puVar15[1] = uVar6;
            if (puVar15[2] <= uVar6) {
              puVar15[1] = uVar6 - puVar15[2];
              *puVar15 = *puVar15 + 1;
            }
            do {
              iVar7 = 0;
              puVar14 = puVar15;
              puVar16 = puVar15;
              do {
                if (puVar16[0xd2] == 0) break;
                bVar1 = *(byte *)(puVar14 + 0xce);
                while ((bVar1 < 3 && (iVar8 = FUN_80054910(puVar15,iVar7), iVar8 == 0))) {
                  bVar1 = *(byte *)(puVar14 + 0xce);
                }
                puVar14 = (uint *)((int)puVar14 + 1);
                iVar7 = iVar7 + 1;
                puVar16 = puVar16 + 1;
              } while (iVar7 < 0x10);
              bVar13 = true;
              iVar7 = 0;
              iVar8 = 0;
              puVar14 = puVar15;
              puVar16 = puVar15;
              do {
                if (puVar14[0xd2] == 0) break;
                cVar2 = *(char *)(puVar16 + 0xce);
                while (cVar2 != '\0') {
                  puVar11 = (uint *)((int)puVar15 +
                                    iVar8 + (uint)*(byte *)(puVar16 + 0xca) * 0xc0 + 0x18);
                  uVar12 = *puVar11;
                  uVar6 = uVar12 + puVar14[0xe2];
                  if ((*puVar15 < uVar6) || (1000000 < uVar12)) break;
                  puVar14[0xe2] = uVar6;
                  cVar2 = *(char *)(puVar16 + 0xca);
                  *(char *)(puVar16 + 0xca) = cVar2 + '\x01';
                  *(char *)(puVar16 + 0xce) = *(char *)(puVar16 + 0xce) + -1;
                  if ((char)(cVar2 + '\x01') == '\x04') {
                    *(undefined *)(puVar16 + 0xca) = 0;
                  }
                  FUN_80054b04(puVar11,puVar15);
                  cVar2 = *(char *)(puVar16 + 0xce);
                  bVar13 = false;
                }
                puVar14 = puVar14 + 1;
                iVar8 = iVar8 + 0xc;
                iVar7 = iVar7 + 1;
                puVar16 = (uint *)((int)puVar16 + 1);
              } while (iVar7 < 0x10);
            } while (!bVar13);
          }
          iVar17 = iVar17 + 1;
          iVar7 = iVar17 * 4;
        } while (iVar17 < aadMem->numSlots);
      }
      uVar3 = (aadMem->sfxSlot).commandsInQueue;
      while (uVar3 != 0) {
        FUN_80056ea8((aadMem->sfxSlot).commandQueue + (uint)(aadMem->sfxSlot).commandOut);
        pAVar5 = aadMem;
        pAVar4 = &aadMem->sfxSlot;
        uVar9 = (aadMem->sfxSlot).commandOut + '\x01';
        (aadMem->sfxSlot).commandOut = uVar9;
        (pAVar5->sfxSlot).commandsInQueue = pAVar4->commandsInQueue - 1;
        if (uVar9 == ' ') {
          (aadMem->sfxSlot).commandOut = '\0';
        }
        uVar3 = (aadMem->sfxSlot).commandsInQueue;
      }
      uVar6 = aadMem->voiceKeyOffRequest & ~aadMem->voiceKeyOnRequest;
      aadMem->voiceKeyOffRequest = uVar6;
      if (uVar6 != 0) {
        FUN_800c0018(0);
      }
      FUN_800c04b4(1,aadMem->voiceReverbRequest);
      FUN_800c04b4(0,~aadMem->voiceReverbRequest);
      if (aadMem->voiceKeyOnRequest != 0) {
        FUN_800c0018(1);
        aadMem->voiceKeyOnRequest = 0;
      }
      iVar17 = (aadMem->masterVolFader).volumeStep;
      bVar13 = false;
      if (iVar17 != 0) {
        iVar7 = aadMem->masterVolume + iVar17;
        if (iVar17 < 0) {
          bVar13 = iVar7 < (aadMem->masterVolFader).targetVolume;
        }
        else {
          if ((aadMem->masterVolFader).targetVolume < iVar7) {
            bVar13 = true;
          }
        }
        if (bVar13) {
          iVar7 = (aadMem->masterVolFader).targetVolume;
          p_Var10 = (aadMem->masterVolFader).fadeCompleteCallback;
          (aadMem->masterVolFader).volumeStep = 0;
          if (p_Var10 != (_func_12 *)0x0) {
            (*p_Var10)();
          }
        }
        FUN_800517e8(iVar7);
      }
      iVar17 = (aadMem->musicMasterVolFader).volumeStep;
      if ((iVar17 != 0) && (bVar13 = false, (aadMem->updateCounter & 1) == 0)) {
        iVar7 = aadMem->musicMasterVol + iVar17;
        if (iVar17 < 0) {
          bVar13 = iVar7 <= (aadMem->musicMasterVolFader).targetVolume;
        }
        else {
          if ((aadMem->musicMasterVolFader).targetVolume <= iVar7) {
            bVar13 = true;
          }
        }
        if (bVar13) {
          iVar7 = (aadMem->musicMasterVolFader).targetVolume;
          p_Var10 = (aadMem->musicMasterVolFader).fadeCompleteCallback;
          (aadMem->musicMasterVolFader).volumeStep = 0;
          if (p_Var10 != (_func_12 *)0x0) {
            (*p_Var10)();
          }
        }
        FUN_80051840(iVar7);
      }
      aadMem->updateCounter = aadMem->updateCounter + 1;
      return;
    }
    in_v0 = in_a1 + in_a3;
  } while( true );
}



// decompiled code
// original method signature: 
// unsigned long /*$ra*/ aadCreateFourCharID(char a /*$a0*/, char b /*$a1*/, char c /*$a2*/, char d /*$a3*/)
 // line 636, offset 0x80051f38
	/* begin block 1 */
		// Start line: 1512
	/* end block 1 */
	// End Line: 1513

	/* begin block 2 */
		// Start line: 1513
	/* end block 2 */
	// End Line: 1514

ulong aadCreateFourCharID(char a,char b,char c,char d)

{
  int in_v0;
  undefined *puVar1;
  undefined3 in_register_00000011;
  int iVar2;
  undefined3 in_register_00000015;
  int unaff_s1;
  int unaff_s2;
  undefined4 unaff_s5;
  _func_43 **pp_Stack00000010;
  undefined4 uStack00000014;
  undefined4 in_stack_00000048;
  
  iVar2 = CONCAT31(in_register_00000011,a);
  do {
    iVar2 = iVar2 + 1;
    if (*(int *)(in_v0 + 0x500) == CONCAT31(in_register_00000015,b)) {
      return (ulong)&DAT_00001006;
    }
    in_v0 = in_v0 + 4;
  } while (iVar2 < 2);
  if (unaff_s2 < 2) {
    if (((&aadMem->updateCounter + unaff_s2)[0x140] == 2) &&
       ((&aadMem->updateCounter + unaff_s2)[0x142] != 0)) {
      FUN_8005234c();
    }
    aadMem->dynamicBankStatus[unaff_s2] = 1;
    FUN_800bfde8();
    FUN_800bfde8(unaff_s1 + 0x20);
    *(int *)(unaff_s1 + 0x40) = unaff_s2;
    *(undefined4 *)(unaff_s1 + 0x44) = unaff_s5;
    *(undefined4 *)(unaff_s1 + 0x54) = 0;
    *(undefined4 *)(unaff_s1 + 0x48) = in_stack_00000048;
    uStack00000014 = 4;
    pp_Stack00000010 = aadMem->dynamicSoundBankData + unaff_s2;
    (*aadMem->nonBlockLoadProc)();
    puVar1 = (undefined *)0x0;
  }
  else {
    puVar1 = &DAT_00001005;
  }
  return (ulong)puVar1;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadLoadDynamicSoundBank(char *sndFileName /*$s3*/, char *smpFileName /*$s4*/, int dynamicBankIndex /*$s2*/, int loadOption /*$s5*/, TDRFuncPtr_aadLoadDynamicSoundBank4retProc retProc /*stack 16*/)
 // line 644, offset 0x80051f60
	/* begin block 1 */
		// Start line: 645
		// Start offset: 0x80051F60
		// Variables:
	// 		int i; // $a0
	// 		struct AadDynamicBankLoadInfo *info; // $s1
	/* end block 1 */
	// End offset: 0x80052094
	// End Line: 699

	/* begin block 2 */
		// Start line: 1528
	/* end block 2 */
	// End Line: 1529

int aadLoadDynamicSoundBank
              (char *sndFileName,char *smpFileName,int dynamicBankIndex,int loadOption,
              TDRFuncPtr_aadLoadDynamicSoundBank4retProc retProc)

{
  return (int)&DAT_00001005;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadLoadDynamicSoundBankReturn(void *loadedDataPtr /*$a0*/, void *data /*$s3*/, void *data2 /*$a2*/)
 // line 704, offset 0x800520b8
	/* begin block 1 */
		// Start line: 705
		// Start offset: 0x800520B8
		// Variables:
	// 		int dynamicBankIndex; // $s1
	// 		int error; // $s0
	/* end block 1 */
	// End offset: 0x8005216C
	// End Line: 772

	/* begin block 2 */
		// Start line: 1693
	/* end block 2 */
	// End Line: 1694

void aadLoadDynamicSoundBankReturn(void *loadedDataPtr,void *data,void *data2)

{
  int in_v0;
  uint unaff_s1;
  int unaff_s2;
  int unaff_s3;
  
  *(undefined4 *)(in_v0 + unaff_s2 + 0x508) = 0;
  if (*(code **)(unaff_s3 + 0x48) != (code *)0x0) {
    (**(code **)(unaff_s3 + 0x48))(unaff_s1 & 0xffff);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadLoadDynamicSoundBankReturn2(void *loadedDataPtr /*$a0*/, long loadedDataSize /*$s2*/, short status /*$s5*/, void *data1 /*$a3*/, void *data2 /*stack 16*/)
 // line 782, offset 0x80052188
	/* begin block 1 */
		// Start line: 783
		// Start offset: 0x80052188
		// Variables:
	// 		unsigned char *dataPtr; // $s1
	// 		struct AadDynamicBankLoadInfo *info; // $s0
	// 		int dynamicBankIndex; // $s3
	// 		int error; // $v0

		/* begin block 1.1 */
			// Start line: 866
			// Start offset: 0x800522FC
			// Variables:
		// 		int i; // $a2
		/* end block 1.1 */
		// End offset: 0x80052390
		// End Line: 880
	/* end block 1 */
	// End offset: 0x80052390
	// End Line: 882

	/* begin block 2 */
		// Start line: 1851
	/* end block 2 */
	// End Line: 1852

void aadLoadDynamicSoundBankReturn2
               (void *loadedDataPtr,long loadedDataSize,short status,void *data1,void *data2)

{
  uint in_v0;
  int in_v1;
  int unaff_s0;
  int unaff_s1;
  
  *(uint *)(in_v1 + 0x500) = in_v0 | 0x80;
  if (*(int *)(in_v1 + 0x508) != 0) {
    (**(code **)(loadedDataSize + 0x73c))();
    *(undefined4 *)((int)aadMem->dynamicSoundBankData + unaff_s1) = 0;
  }
  if (*(code **)(unaff_s0 + 0x48) != (code *)0x0) {
    (**(code **)(unaff_s0 + 0x48))();
  }
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadFreeDynamicSoundBank(int dynamicBankIndex /*$a0*/)
 // line 900, offset 0x800523b4
	/* begin block 1 */
		// Start line: 2119
	/* end block 1 */
	// End Line: 2120

int aadFreeDynamicSoundBank(int dynamicBankIndex)

{
  int in_v0;
  int in_v1;
  
  *(undefined4 *)(in_v1 + 0x508) = 0;
  return in_v0;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadOpenDynamicSoundBank(unsigned char *soundBank /*$a0*/, int dynamicBankIndex /*$s1*/)
 // line 930, offset 0x80052430
	/* begin block 1 */
		// Start line: 931
		// Start offset: 0x80052430
		// Variables:
	// 		struct AadSoundBankHdr *soundBankHdr; // $s0
	// 		struct AadProgramAtr *programAtr; // $v0
	// 		struct AadToneAtr *toneAtr; // $v0
	// 		unsigned long *waveAddr; // $v0
	// 		unsigned long *sequenceOffsetTbl; // $a0
	// 		unsigned long *sequenceLabelOffsetTbl; // $a1
	// 		unsigned char *sequenceBase; // $a3
	// 		int i; // $t2
	/* end block 1 */
	// End offset: 0x8005253C
	// End Line: 979

	/* begin block 2 */
		// Start line: 2186
	/* end block 2 */
	// End Line: 2187

int aadOpenDynamicSoundBank(uchar *soundBank,int dynamicBankIndex)

{
  int in_v0;
  int iVar1;
  int iVar2;
  int iVar3;
  int *piVar4;
  int *piVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int in_t1;
  int in_t2;
  int unaff_s0;
  
  iVar2 = *(int *)(unaff_s0 + 0xc);
  iVar6 = *(int *)(unaff_s0 + 0x10);
  iVar7 = *(int *)(unaff_s0 + 0x14);
  iVar3 = *(int *)(unaff_s0 + 0x18);
  iVar8 = *(int *)(unaff_s0 + 0x1c);
  iVar1 = (int)&aadMem->updateCounter + in_t1;
  *(int *)(iVar1 + 0x4d8) = unaff_s0 + in_v0;
  iVar2 = unaff_s0 + in_v0 + iVar2 * 8;
  *(int *)(iVar1 + 0x4e0) = iVar2;
  iVar2 = iVar2 + iVar6 * 0x10;
  piVar5 = (int *)(iVar2 + iVar7 * 4);
  piVar4 = piVar5 + iVar3;
  *(int *)(iVar1 + 0x4d0) = unaff_s0;
  *(int *)(iVar1 + 0x4e8) = iVar2;
  *(int **)(iVar1 + 0x4f0) = piVar5;
  *(int **)(iVar1 + 0x4f8) = piVar4;
  if (0 < *(int *)(unaff_s0 + 0x18)) {
    do {
      *(int *)(in_t2 * 4 + *(int *)(iVar1 + 0x4f0)) = (int)piVar4 + *piVar5 + iVar8 * 4;
      in_t2 = in_t2 + 1;
      piVar5 = piVar5 + 1;
    } while (in_t2 < *(int *)(unaff_s0 + 0x18));
  }
  return 0;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadLoadDynamicSfx(char *fileName /*$a3*/, long directoryID /*$a1*/, long flags /*$a2*/)
 // line 996, offset 0x80052550
	/* begin block 1 */
		// Start line: 997
		// Start offset: 0x80052550
		// Variables:
	// 		struct AadDynamicLoadRequest *loadReq; // $s0
	/* end block 1 */
	// End offset: 0x800525F4
	// End Line: 1020

	/* begin block 2 */
		// Start line: 2390
	/* end block 2 */
	// End Line: 2391

int aadLoadDynamicSfx(char *fileName,long directoryID,long flags)

{
  int *piVar1;
  AadMemoryStruct *pAVar2;
  int unaff_s0;
  
  *(long *)(unaff_s0 + 8) = directoryID;
  *(long *)(unaff_s0 + 0xc) = flags;
  FUN_800bfde8();
  pAVar2 = aadMem;
  piVar1 = &aadMem->numLoadReqsQueued;
  aadMem->nextLoadReqIn = aadMem->nextLoadReqIn + 1U & 0xf;
  pAVar2->numLoadReqsQueued = *piVar1 + 1;
  return *(int *)(unaff_s0 + 4);
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadFreeDynamicSfx(int handle /*$a0*/)
 // line 1046, offset 0x80052604
	/* begin block 1 */
		// Start line: 1048
		// Start offset: 0x80052604
		// Variables:
	// 		struct AadDynamicLoadRequest *loadReq; // $a1
	// 		int i; // $a2
	/* end block 1 */
	// End offset: 0x800526D8
	// End Line: 1079

	/* begin block 2 */
		// Start line: 2516
	/* end block 2 */
	// End Line: 2517

	/* begin block 3 */
		// Start line: 2517
	/* end block 3 */
	// End Line: 2518

	/* begin block 4 */
		// Start line: 2524
	/* end block 4 */
	// End Line: 2525

int aadFreeDynamicSfx(int handle)

{
  uint uVar1;
  undefined4 *puVar2;
  int in_a2;
  
  if (*(int *)(in_a2 + 0x748) < 0x10) {
    uVar1 = *(int *)(in_a2 + 0x744) - 1U & 0xf;
    puVar2 = (undefined4 *)(in_a2 + uVar1 * 0x1c + 0x518);
    *(uint *)(in_a2 + 0x744) = uVar1;
    *puVar2 = 1;
    puVar2[1] = handle;
    *(int *)(in_a2 + 0x748) = *(int *)(in_a2 + 0x748) + 1;
    return 0;
  }
  return (int)&DAT_0000100f;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadRelocateMusicMemoryBegin()
 // line 1123, offset 0x800526e0
	/* begin block 1 */
		// Start line: 2692
	/* end block 1 */
	// End Line: 2693

	/* begin block 2 */
		// Start line: 2694
	/* end block 2 */
	// End Line: 2695

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadRelocateMusicMemoryBegin(void)

{
  AadMemoryStruct *pAVar1;
  int in_v0;
  int in_v1;
  int *piVar2;
  uint uVar3;
  int in_a0;
  int iVar4;
  int in_a1;
  uint in_a2;
  int iVar5;
  int iVar6;
  int in_t0;
  int iVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int in_t7;
  int in_t8;
  int in_t9;
  
  *(int *)(in_t0 + 0x4d0) = in_a0;
  *(int *)(in_t0 + 0x4e8) = in_v0 + in_a1;
  *(int *)(in_t0 + 0x4f0) = in_v1 + in_a1;
  iVar5 = 0;
  if (0 < *(int *)(in_a0 + 0x18)) {
    do {
      piVar2 = (int *)(iVar5 * 4 + *(int *)(in_t0 + 0x4f0));
      *piVar2 = *piVar2 + in_a1;
      iVar5 = iVar5 + 1;
    } while (iVar5 < *(int *)(in_a0 + 0x18));
  }
  *(int *)(in_t0 + 0x4f8) = *(int *)(in_t0 + 0x4f8) + in_a1;
  iVar12 = 0;
  iVar5 = in_t8;
  if (0 < *(int *)(in_t8 + 4)) {
    do {
      iVar10 = *(int *)(iVar5 + 0x34);
      if ((*(char *)(iVar10 + 0x53e) != -1) && (*(int *)(iVar10 + 0x55c) == in_t7)) {
        iVar8 = 0;
        iVar11 = 0;
        iVar7 = iVar10;
        do {
          if (*(int *)(iVar7 + 0x348) != 0) {
            *(int *)(iVar7 + 0x348) = *(int *)(iVar7 + 0x348) + in_a1;
            iVar6 = 0;
            iVar4 = iVar11;
            if (*(char *)(iVar10 + iVar8 + 0x4e8) != '\0') {
              do {
                *(int *)(iVar10 + iVar4 + 1000) = *(int *)(iVar10 + iVar4 + 1000) + in_a1;
                iVar6 = iVar6 + 1;
                iVar4 = iVar4 + 0x40;
              } while (iVar6 < (int)(uint)*(byte *)(iVar10 + iVar8 + 0x4e8));
            }
          }
          iVar11 = iVar11 + 4;
          iVar8 = iVar8 + 1;
          iVar7 = iVar7 + 4;
        } while (iVar8 < 0x10);
      }
      iVar12 = iVar12 + 1;
      iVar5 = iVar5 + 4;
    } while (iVar12 < *(int *)(in_t8 + 4));
  }
  pAVar1 = aadMem;
  iVar12 = 0;
  iVar5 = 0x1dc;
  uVar9 = in_a2 + *(int *)(in_t9 + 4) + -8;
  do {
    iVar10 = (int)&pAVar1->updateCounter + iVar5;
    if (-1 < *(char *)(iVar10 + 8)) {
      uVar3 = *(uint *)(iVar10 + 0x14);
      if ((in_a2 <= uVar3) && (uVar3 < uVar9)) {
        *(int *)(iVar10 + 0x14) = uVar3 + in_a1;
      }
      uVar3 = *(uint *)(iVar10 + 0x18);
      if ((in_a2 <= uVar3) && (uVar3 < uVar9)) {
        *(int *)(iVar10 + 0x18) = uVar3 + in_a1;
      }
    }
    iVar12 = iVar12 + 1;
    iVar5 = iVar5 + 0x1c;
  } while (iVar12 < 0x18);
  aadMem->flags = aadMem->flags & 0xfffffffd;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadRelocateMusicMemoryEnd(struct MemHeader *newAddress /*$t9*/, long offset /*$a1*/, void *oldAddress /*$a2*/)
 // line 1132, offset 0x800526fc
	/* begin block 1 */
		// Start line: 1133
		// Start offset: 0x800526FC
		// Variables:
	// 		int bank; // $t7

		/* begin block 1.1 */
			// Start line: 1141
			// Start offset: 0x8005271C
			// Variables:
		// 		int slotNumber; // $t5
		// 		int i; // $a3
		// 		struct AadSoundBankHdr *bankHdr; // $a0

			/* begin block 1.1.1 */
				// Start line: 1160
				// Start offset: 0x800527C4
				// Variables:
			// 		struct _AadSequenceSlot *slot; // $t3

				/* begin block 1.1.1.1 */
					// Start line: 1163
					// Start offset: 0x800527EC
					// Variables:
				// 		int track; // $t1
				/* end block 1.1.1.1 */
				// End offset: 0x80052860
				// End Line: 1179
			/* end block 1.1.1 */
			// End offset: 0x80052860
			// End Line: 1180
		/* end block 1.1 */
		// End offset: 0x8005287C
		// End Line: 1183

		/* begin block 1.2 */
			// Start line: 1186
			// Start offset: 0x8005288C
			// Variables:
		// 		struct AadSynthVoice *voice; // $a0
		// 		int i; // $t0
		// 		long dataSize; // $v0
		/* end block 1.2 */
		// End offset: 0x80052908
		// End Line: 1205
	/* end block 1 */
	// End offset: 0x80052908
	// End Line: 1207

	/* begin block 2 */
		// Start line: 2710
	/* end block 2 */
	// End Line: 2711

void aadRelocateMusicMemoryEnd(MemHeader *newAddress,long offset,void *oldAddress)

{
  AadMemoryStruct *pAVar1;
  int in_v0;
  int *piVar2;
  void *pvVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int in_t0;
  int iVar7;
  int iVar8;
  void *pvVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int in_t7;
  int in_t8;
  int in_t9;
  
  iVar5 = 0;
  if (0 < in_v0) {
    do {
      piVar2 = (int *)(iVar5 * 4 + *(int *)(in_t0 + 0x4f0));
      *piVar2 = *piVar2 + offset;
      iVar5 = iVar5 + 1;
    } while (iVar5 < *(int *)(newAddress + 3));
  }
  *(int *)(in_t0 + 0x4f8) = *(int *)(in_t0 + 0x4f8) + offset;
  iVar12 = 0;
  iVar5 = in_t8;
  if (0 < *(int *)(in_t8 + 4)) {
    do {
      iVar10 = *(int *)(iVar5 + 0x34);
      if ((*(char *)(iVar10 + 0x53e) != -1) && (*(int *)(iVar10 + 0x55c) == in_t7)) {
        iVar8 = 0;
        iVar11 = 0;
        iVar7 = iVar10;
        do {
          if (*(int *)(iVar7 + 0x348) != 0) {
            *(int *)(iVar7 + 0x348) = *(int *)(iVar7 + 0x348) + offset;
            iVar6 = 0;
            iVar4 = iVar11;
            if (*(char *)(iVar10 + iVar8 + 0x4e8) != '\0') {
              do {
                *(int *)(iVar10 + iVar4 + 1000) = *(int *)(iVar10 + iVar4 + 1000) + offset;
                iVar6 = iVar6 + 1;
                iVar4 = iVar4 + 0x40;
              } while (iVar6 < (int)(uint)*(byte *)(iVar10 + iVar8 + 0x4e8));
            }
          }
          iVar11 = iVar11 + 4;
          iVar8 = iVar8 + 1;
          iVar7 = iVar7 + 4;
        } while (iVar8 < 0x10);
      }
      iVar12 = iVar12 + 1;
      iVar5 = iVar5 + 4;
    } while (iVar12 < *(int *)(in_t8 + 4));
  }
  pAVar1 = aadMem;
  iVar12 = 0;
  iVar5 = 0x1dc;
  pvVar9 = (void *)((int)oldAddress + *(int *)(in_t9 + 4) + -8);
  do {
    iVar10 = (int)&pAVar1->updateCounter + iVar5;
    if (-1 < *(char *)(iVar10 + 8)) {
      pvVar3 = *(void **)(iVar10 + 0x14);
      if ((oldAddress <= pvVar3) && (pvVar3 < pvVar9)) {
        *(int *)(iVar10 + 0x14) = (int)pvVar3 + offset;
      }
      pvVar3 = *(void **)(iVar10 + 0x18);
      if ((oldAddress <= pvVar3) && (pvVar3 < pvVar9)) {
        *(int *)(iVar10 + 0x18) = (int)pvVar3 + offset;
      }
    }
    iVar12 = iVar12 + 1;
    iVar5 = iVar5 + 0x1c;
  } while (iVar12 < 0x18);
  aadMem->flags = aadMem->flags & 0xfffffffd;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadRelocateSfxMemory(void *oldAddress /*$a0*/, int offset /*$a1*/)
 // line 1217, offset 0x80052924
	/* begin block 1 */
		// Start line: 1219
		// Start offset: 0x80052924
		// Variables:
	// 		struct _AadDynSfxFileHdr *snfFile; // $v1
	/* end block 1 */
	// End offset: 0x80052984
	// End Line: 1254

	/* begin block 2 */
		// Start line: 2982
	/* end block 2 */
	// End Line: 2983

	/* begin block 3 */
		// Start line: 2983
	/* end block 3 */
	// End Line: 2984

	/* begin block 4 */
		// Start line: 2988
	/* end block 4 */
	// End Line: 2989

void aadRelocateSfxMemory(void *oldAddress,int offset)

{
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadGetNumLoadsQueued()
 // line 1257, offset 0x8005298c
	/* begin block 1 */
		// Start line: 3062
	/* end block 1 */
	// End Line: 3063

	/* begin block 2 */
		// Start line: 3064
	/* end block 2 */
	// End Line: 3065

/* WARNING: Unknown calling convention yet parameter storage is locked */

int aadGetNumLoadsQueued(void)

{
  int *piVar1;
  ulong *puVar2;
  AadMemoryStruct *pAVar3;
  int in_v0;
  undefined *puVar4;
  int in_v1;
  long lVar5;
  int in_a0;
  int iVar6;
  int in_a1;
  ushort *puVar7;
  char *pcVar8;
  int unaff_s0;
  _AadDynSfxFileHdr *p_Var9;
  char *pcVar10;
  _AadDynSfxFileHdr *p_Var11;
  AadDynamicLoadRequest *pAVar12;
  
  pAVar3 = aadMem;
  while( true ) {
    in_a0 = in_a0 + 1;
    if (in_v0 == in_a1) {
      return in_v0;
    }
    if (1 < in_a0) break;
    in_v0 = *(int *)(in_v1 + 0x504);
    in_v1 = in_v1 + 4;
  }
  if ((aadMem->numLoadReqsQueued == 0) || ((aadMem->sramDefragInfo).status != 0)) {
LAB_80052c44:
    if (gDefragRequest == 0) goto LAB_80052c70;
  }
  else {
    if (gDefragRequest == 0) {
      iVar6 = aadMem->nextLoadReqOut;
      piVar1 = &aadMem->numLoadReqsQueued;
      aadMem->nextLoadReqOut = iVar6 + 1U & 0xf;
      pAVar12 = pAVar3->loadRequestQueue + iVar6;
      pAVar3->numLoadReqsQueued = *piVar1 + -1;
      iVar6 = pAVar12->type;
      if (iVar6 == 1) {
        p_Var11 = pAVar3->firstDynSfxFile;
        while( true ) {
          if (p_Var11 == (_AadDynSfxFileHdr *)0x0) goto LAB_80052c30;
          if ((uint)p_Var11->handle == pAVar12->handle) break;
          p_Var11 = p_Var11->nextDynSfxFile;
        }
        iVar6 = 0;
        p_Var9 = p_Var11 + 1;
        if (p_Var11->numSfxInFile != 0) {
          do {
            puVar2 = &p_Var9->snfID;
            p_Var9 = (_AadDynSfxFileHdr *)((int)&p_Var9->snfID + 2);
            FUN_80053218((uint)*(ushort *)puVar2);
            iVar6 = iVar6 + 1;
          } while (iVar6 < (int)(uint)p_Var11->numSfxInFile);
        }
        if (p_Var11->prevDynSfxFile == (_AadDynSfxFileHdr *)0x0) {
          aadMem->firstDynSfxFile = p_Var11->nextDynSfxFile;
        }
        else {
          p_Var11->prevDynSfxFile->nextDynSfxFile = p_Var11->nextDynSfxFile;
        }
        if (p_Var11->nextDynSfxFile != (_AadDynSfxFileHdr *)0x0) {
          p_Var11->nextDynSfxFile->prevDynSfxFile = p_Var11->prevDynSfxFile;
        }
        (*aadMem->memoryFreeProc)(p_Var11);
        gSramFullAlarm = 0;
LAB_80052c30:
        iVar6 = FUN_8005398c();
        if (iVar6 != 0) {
          gDefragRequest = 1;
        }
        goto LAB_80052c44;
      }
      if ((iVar6 < 2) && (iVar6 == 0)) {
        pcVar10 = pAVar12->fileName;
        FUN_800bd564(&stack0x00000018,pcVar10);
        puVar4 = (undefined *)FUN_800bfd78(&stack0x00000018,sfxCmdFunction);
        if (puVar4 != (undefined *)0x0) {
          *puVar4 = 0;
        }
        if ((pAVar12->flags & 1U) == 0) {
          FUN_800741fc();
          puVar7 = USHORT_ARRAY_800cef84;
          pcVar8 = pcVar10;
        }
        else {
          FUN_800741fc();
          puVar7 = (ushort *)0x800cef4c;
          pcVar8 = &stack0x00000018;
        }
        FUN_800741fc(unaff_s0 + 0x28,puVar7,pcVar8,pcVar10);
        *(int *)(unaff_s0 + 0x50) = pAVar12->handle;
        iVar6 = pAVar12->directoryID;
        gSramFullAlarm = 0;
        *(int *)(unaff_s0 + 0x54) = iVar6;
        lVar5 = pAVar12->flags;
        *(undefined4 *)(unaff_s0 + 0x5c) = 1;
        *(undefined4 *)(unaff_s0 + 0x78) = 0;
        *(undefined4 *)(unaff_s0 + 0x6c) = 0;
        *(undefined4 *)(unaff_s0 + 0x74) = 0;
        *(long *)(unaff_s0 + 0x58) = lVar5;
        if (iVar6 != 0) {
          FUN_80037e0c();
        }
        (*aadMem->nonBlockLoadProc)();
        if (*(int *)(unaff_s0 + 0x54) != 0) {
          FUN_80037e0c(0);
        }
      }
      goto LAB_80052c44;
    }
  }
  iVar6 = FUN_8004039c();
  if (iVar6 == 0) {
    gDefragRequest = 0;
    (aadMem->sramDefragInfo).status = 1;
  }
LAB_80052c70:
  iVar6 = FUN_80053a40();
  return iVar6;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadPurgeLoadQueue()
 // line 1265, offset 0x800529a0
	/* begin block 1 */
		// Start line: 3078
	/* end block 1 */
	// End Line: 3079

	/* begin block 2 */
		// Start line: 3080
	/* end block 2 */
	// End Line: 3081

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadPurgeLoadQueue(void)

{
  int *piVar1;
  ulong *puVar2;
  AadMemoryStruct *pAVar3;
  undefined *puVar4;
  long lVar5;
  int iVar6;
  ushort *puVar7;
  char *pcVar8;
  int unaff_s0;
  _AadDynSfxFileHdr *p_Var9;
  char *pcVar10;
  _AadDynSfxFileHdr *p_Var11;
  AadDynamicLoadRequest *pAVar12;
  
  pAVar3 = aadMem;
  if ((aadMem->numLoadReqsQueued == 0) || ((aadMem->sramDefragInfo).status != 0)) {
LAB_80052c44:
    if (gDefragRequest == 0) goto LAB_80052c70;
  }
  else {
    if (gDefragRequest == 0) {
      iVar6 = aadMem->nextLoadReqOut;
      piVar1 = &aadMem->numLoadReqsQueued;
      aadMem->nextLoadReqOut = iVar6 + 1U & 0xf;
      pAVar12 = pAVar3->loadRequestQueue + iVar6;
      pAVar3->numLoadReqsQueued = *piVar1 + -1;
      iVar6 = pAVar12->type;
      if (iVar6 == 1) {
        p_Var11 = pAVar3->firstDynSfxFile;
        if (p_Var11 != (_AadDynSfxFileHdr *)0x0) {
LAB_80052b68:
          if ((uint)p_Var11->handle != pAVar12->handle) goto LAB_80052c20;
          iVar6 = 0;
          p_Var9 = p_Var11 + 1;
          if (p_Var11->numSfxInFile != 0) {
            do {
              puVar2 = &p_Var9->snfID;
              p_Var9 = (_AadDynSfxFileHdr *)((int)&p_Var9->snfID + 2);
              FUN_80053218((uint)*(ushort *)puVar2);
              iVar6 = iVar6 + 1;
            } while (iVar6 < (int)(uint)p_Var11->numSfxInFile);
          }
          if (p_Var11->prevDynSfxFile == (_AadDynSfxFileHdr *)0x0) {
            aadMem->firstDynSfxFile = p_Var11->nextDynSfxFile;
          }
          else {
            p_Var11->prevDynSfxFile->nextDynSfxFile = p_Var11->nextDynSfxFile;
          }
          if (p_Var11->nextDynSfxFile != (_AadDynSfxFileHdr *)0x0) {
            p_Var11->nextDynSfxFile->prevDynSfxFile = p_Var11->prevDynSfxFile;
          }
          (*aadMem->memoryFreeProc)(p_Var11);
          gSramFullAlarm = 0;
        }
LAB_80052c30:
        iVar6 = FUN_8005398c();
        if (iVar6 != 0) {
          gDefragRequest = 1;
        }
      }
      else {
        if ((iVar6 < 2) && (iVar6 == 0)) {
          pcVar10 = pAVar12->fileName;
          FUN_800bd564(&stack0x00000018,pcVar10);
          puVar4 = (undefined *)FUN_800bfd78(&stack0x00000018,sfxCmdFunction);
          if (puVar4 != (undefined *)0x0) {
            *puVar4 = 0;
          }
          if ((pAVar12->flags & 1U) == 0) {
            FUN_800741fc();
            puVar7 = USHORT_ARRAY_800cef84;
            pcVar8 = pcVar10;
          }
          else {
            FUN_800741fc();
            puVar7 = (ushort *)0x800cef4c;
            pcVar8 = &stack0x00000018;
          }
          FUN_800741fc(unaff_s0 + 0x28,puVar7,pcVar8,pcVar10);
          *(int *)(unaff_s0 + 0x50) = pAVar12->handle;
          iVar6 = pAVar12->directoryID;
          gSramFullAlarm = 0;
          *(int *)(unaff_s0 + 0x54) = iVar6;
          lVar5 = pAVar12->flags;
          *(undefined4 *)(unaff_s0 + 0x5c) = 1;
          *(undefined4 *)(unaff_s0 + 0x78) = 0;
          *(undefined4 *)(unaff_s0 + 0x6c) = 0;
          *(undefined4 *)(unaff_s0 + 0x74) = 0;
          *(long *)(unaff_s0 + 0x58) = lVar5;
          if (iVar6 != 0) {
            FUN_80037e0c();
          }
          (*aadMem->nonBlockLoadProc)();
          if (*(int *)(unaff_s0 + 0x54) != 0) {
            FUN_80037e0c(0);
          }
        }
      }
      goto LAB_80052c44;
    }
  }
  iVar6 = FUN_8004039c();
  if (iVar6 == 0) {
    gDefragRequest = 0;
    (aadMem->sramDefragInfo).status = 1;
  }
LAB_80052c70:
  FUN_80053a40();
  return;
LAB_80052c20:
  p_Var11 = p_Var11->nextDynSfxFile;
  if (p_Var11 == (_AadDynSfxFileHdr *)0x0) goto LAB_80052c30;
  goto LAB_80052b68;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadProcessLoadQueue()
 // line 1277, offset 0x800529b8
	/* begin block 1 */
		// Start line: 1278
		// Start offset: 0x800529B8
		// Variables:
	// 		struct AadDynamicSfxLoadInfo *info; // $s0
	// 		int i; // $a0
	// 		char *p; // $v0

		/* begin block 1.1 */
			// Start line: 1303
			// Start offset: 0x80052A40
			// Variables:
		// 		struct AadDynamicLoadRequest *loadReq; // $s2

			/* begin block 1.1.1 */
				// Start line: 1314
				// Start offset: 0x80052A90
				// Variables:
			// 		char areaName[12]; // stack offset -32

				/* begin block 1.1.1.1 */
					// Start line: 1335
					// Start offset: 0x80052ACC
				/* end block 1.1.1.1 */
				// End offset: 0x80052ACC
				// End Line: 1335

				/* begin block 1.1.1.2 */
					// Start line: 1340
					// Start offset: 0x80052AF8
				/* end block 1.1.1.2 */
				// End offset: 0x80052B28
				// End Line: 1342
			/* end block 1.1.1 */
			// End offset: 0x80052BB0
			// End Line: 1361

			/* begin block 1.1.2 */
				// Start line: 1366
				// Start offset: 0x80052BC0
				// Variables:
			// 		int i; // $s2
			// 		struct _AadDynSfxFileHdr *snfFile; // $s1
			// 		unsigned short *sfxIDListPtr; // $v1
			/* end block 1.1.2 */
			// End offset: 0x80052C98
			// End Line: 1398
		/* end block 1.1 */
		// End offset: 0x80052CAC
		// End Line: 1406
	/* end block 1 */
	// End offset: 0x80052CE0
	// End Line: 1414

	/* begin block 2 */
		// Start line: 3102
	/* end block 2 */
	// End Line: 3103

	/* begin block 3 */
		// Start line: 3114
	/* end block 3 */
	// End Line: 3115

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadProcessLoadQueue(void)

{
  ushort uVar1;
  undefined *puVar2;
  int iVar3;
  int iVar4;
  int in_a1;
  ushort *puVar5;
  int *piVar6;
  int unaff_s0;
  int *piVar7;
  int *piVar8;
  
  if (*(int *)(in_a1 + 0x7e8) == 0) {
    if (gDefragRequest == 0) {
      iVar4 = *(int *)(in_a1 + 0x744);
      *(uint *)(in_a1 + 0x744) = iVar4 + 1U & 0xf;
      piVar8 = (int *)(in_a1 + iVar4 * 0x1c + 0x518);
      *(int *)(in_a1 + 0x748) = *(int *)(in_a1 + 0x748) + -1;
      iVar4 = *piVar8;
      if (iVar4 == 1) {
        iVar4 = *(int *)(in_a1 + 0x7e0);
        if (iVar4 != 0) {
LAB_80052b68:
          if ((uint)*(ushort *)(iVar4 + 8) != piVar8[1]) goto LAB_80052c20;
          iVar3 = 0;
          puVar5 = (ushort *)(iVar4 + 0x14);
          if (*(short *)(iVar4 + 10) != 0) {
            do {
              uVar1 = *puVar5;
              puVar5 = puVar5 + 1;
              FUN_80053218((uint)uVar1);
              iVar3 = iVar3 + 1;
            } while (iVar3 < (int)(uint)*(ushort *)(iVar4 + 10));
          }
          if (*(int *)(iVar4 + 0xc) == 0) {
            aadMem->firstDynSfxFile = *(_AadDynSfxFileHdr **)(iVar4 + 0x10);
          }
          else {
            *(undefined4 *)(*(int *)(iVar4 + 0xc) + 0x10) = *(undefined4 *)(iVar4 + 0x10);
          }
          if (*(int *)(iVar4 + 0x10) != 0) {
            *(undefined4 *)(*(int *)(iVar4 + 0x10) + 0xc) = *(undefined4 *)(iVar4 + 0xc);
          }
          (*aadMem->memoryFreeProc)(iVar4);
          gSramFullAlarm = 0;
        }
LAB_80052c30:
        iVar4 = FUN_8005398c();
        if (iVar4 != 0) {
          gDefragRequest = 1;
        }
      }
      else {
        if ((iVar4 < 2) && (iVar4 == 0)) {
          piVar7 = piVar8 + 4;
          FUN_800bd564(&stack0x00000018,piVar7);
          puVar2 = (undefined *)FUN_800bfd78(&stack0x00000018,sfxCmdFunction);
          if (puVar2 != (undefined *)0x0) {
            *puVar2 = 0;
          }
          if ((piVar8[3] & 1U) == 0) {
            FUN_800741fc();
            puVar5 = USHORT_ARRAY_800cef84;
            piVar6 = piVar7;
          }
          else {
            FUN_800741fc();
            puVar5 = (ushort *)0x800cef4c;
            piVar6 = (int *)&stack0x00000018;
          }
          FUN_800741fc(unaff_s0 + 0x28,puVar5,piVar6,piVar7);
          *(int *)(unaff_s0 + 0x50) = piVar8[1];
          iVar4 = piVar8[2];
          gSramFullAlarm = 0;
          *(int *)(unaff_s0 + 0x54) = iVar4;
          iVar3 = piVar8[3];
          *(undefined4 *)(unaff_s0 + 0x5c) = 1;
          *(undefined4 *)(unaff_s0 + 0x78) = 0;
          *(undefined4 *)(unaff_s0 + 0x6c) = 0;
          *(undefined4 *)(unaff_s0 + 0x74) = 0;
          *(int *)(unaff_s0 + 0x58) = iVar3;
          if (iVar4 != 0) {
            FUN_80037e0c();
          }
          (*aadMem->nonBlockLoadProc)();
          if (*(int *)(unaff_s0 + 0x54) != 0) {
            FUN_80037e0c(0);
          }
        }
      }
      goto LAB_80052c44;
    }
  }
  else {
LAB_80052c44:
    if (gDefragRequest == 0) goto LAB_80052c70;
  }
  iVar4 = FUN_8004039c();
  if (iVar4 == 0) {
    gDefragRequest = 0;
    (aadMem->sramDefragInfo).status = 1;
  }
LAB_80052c70:
  FUN_80053a40();
  return;
LAB_80052c20:
  iVar4 = *(int *)(iVar4 + 0x10);
  if (iVar4 == 0) goto LAB_80052c30;
  goto LAB_80052b68;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadLoadDynamicSfxAbort(struct AadDynamicSfxLoadInfo *info /*$s0*/, int error /*$a1*/)
 // line 1417, offset 0x80052cf8
	/* begin block 1 */
		// Start line: 3422
	/* end block 1 */
	// End Line: 3423

void aadLoadDynamicSfxAbort(AadDynamicSfxLoadInfo *info,int error)

{
  code *in_v0;
  int unaff_s0;
  
  (*in_v0)();
  *(undefined4 *)(unaff_s0 + 0x5c) = 0;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadLoadDynamicSfxDone(struct AadDynamicSfxLoadInfo *info /*$a0*/)
 // line 1443, offset 0x80052d7c
	/* begin block 1 */
		// Start line: 3474
	/* end block 1 */
	// End Line: 3475

	/* begin block 2 */
		// Start line: 3476
	/* end block 2 */
	// End Line: 3477

void aadLoadDynamicSfxDone(AadDynamicSfxLoadInfo *info)

{
  AadMemoryStruct *pAVar1;
  _AadDynSfxFileHdr *p_Var2;
  _AadDynSfxFileHdr *p_Var3;
  int unaff_s0;
  
  pAVar1 = aadMem;
  if (*(short *)(*(int *)(unaff_s0 + 0x78) + 4) == 0x100) {
    *(undefined2 *)(*(int *)(unaff_s0 + 0x78) + 8) = *(undefined2 *)(unaff_s0 + 0x50);
    p_Var3 = pAVar1->firstDynSfxFile;
    if (p_Var3 == (_AadDynSfxFileHdr *)0x0) {
      pAVar1->firstDynSfxFile = *(_AadDynSfxFileHdr **)(unaff_s0 + 0x78);
      *(undefined4 *)(*(int *)(unaff_s0 + 0x78) + 0xc) = 0;
    }
    else {
      p_Var2 = p_Var3->nextDynSfxFile;
      while (p_Var2 != (_AadDynSfxFileHdr *)0x0) {
        p_Var3 = p_Var3->nextDynSfxFile;
        p_Var2 = p_Var3->nextDynSfxFile;
      }
      p_Var3->nextDynSfxFile = *(_AadDynSfxFileHdr **)(unaff_s0 + 0x78);
      *(_AadDynSfxFileHdr **)(*(int *)(unaff_s0 + 0x78) + 0xc) = p_Var3;
    }
    *(undefined4 *)(*(int *)(unaff_s0 + 0x78) + 0x10) = 0;
    *(undefined4 *)(unaff_s0 + 0x60) = 0;
    *(uint *)(unaff_s0 + 0x5c) = *(uint *)(unaff_s0 + 0x5c) | 2;
    if (*(int *)(unaff_s0 + 0x54) != 0) {
      FUN_80037e0c();
    }
    (*aadMem->nonBlockBufferedLoadProc)(unaff_s0 + 0x28,FUN_800536c4);
    if (*(int *)(unaff_s0 + 0x54) != 0) {
      FUN_80037e0c(0);
    }
  }
  else {
    FUN_80052c90(info,&DAT_0000100b);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadLoadDynamicSfxReturn(void *loadedDataPtr /*$a0*/, void *data /*$a1*/, void *data2 /*$a2*/)
 // line 1458, offset 0x80052d84
	/* begin block 1 */
		// Start line: 1459
		// Start offset: 0x80052D84
		// Variables:
	// 		struct _AadDynSfxFileHdr *p; // $v1
	// 		struct AadDynamicSfxLoadInfo *info; // $s0
	/* end block 1 */
	// End offset: 0x80052EE8
	// End Line: 1546

	/* begin block 2 */
		// Start line: 3504
	/* end block 2 */
	// End Line: 3505

void aadLoadDynamicSfxReturn(void *loadedDataPtr,void *data,void *data2)

{
  AadMemoryStruct *pAVar1;
  _AadDynSfxFileHdr *p_Var2;
  _AadDynSfxFileHdr *p_Var3;
  int unaff_s0;
  
  pAVar1 = aadMem;
  if (*(short *)((int)data + 4) == 0x100) {
    *(undefined2 *)((int)data + 8) = *(undefined2 *)(unaff_s0 + 0x50);
    p_Var3 = pAVar1->firstDynSfxFile;
    if (p_Var3 == (_AadDynSfxFileHdr *)0x0) {
      pAVar1->firstDynSfxFile = *(_AadDynSfxFileHdr **)(unaff_s0 + 0x78);
      *(undefined4 *)(*(int *)(unaff_s0 + 0x78) + 0xc) = 0;
    }
    else {
      p_Var2 = p_Var3->nextDynSfxFile;
      while (p_Var2 != (_AadDynSfxFileHdr *)0x0) {
        p_Var3 = p_Var3->nextDynSfxFile;
        p_Var2 = p_Var3->nextDynSfxFile;
      }
      p_Var3->nextDynSfxFile = *(_AadDynSfxFileHdr **)(unaff_s0 + 0x78);
      *(_AadDynSfxFileHdr **)(*(int *)(unaff_s0 + 0x78) + 0xc) = p_Var3;
    }
    *(undefined4 *)(*(int *)(unaff_s0 + 0x78) + 0x10) = 0;
    *(undefined4 *)(unaff_s0 + 0x60) = 0;
    *(uint *)(unaff_s0 + 0x5c) = *(uint *)(unaff_s0 + 0x5c) | 2;
    if (*(int *)(unaff_s0 + 0x54) != 0) {
      FUN_80037e0c();
    }
    (*aadMem->nonBlockBufferedLoadProc)(unaff_s0 + 0x28,FUN_800536c4);
    if (*(int *)(unaff_s0 + 0x54) != 0) {
      FUN_80037e0c(0);
    }
  }
  else {
    FUN_80052c90(loadedDataPtr,&DAT_0000100b);
  }
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadWaveMalloc(unsigned short waveID /*$t6*/, unsigned long waveSize /*$a1*/)
 // line 1561, offset 0x80052efc
	/* begin block 1 */
		// Start line: 1562
		// Start offset: 0x80052EFC
		// Variables:
	// 		struct AadNewSramBlockDesc *sramDesc; // $a2
	// 		struct AadNewSramBlockDesc *bestFit; // $t1
	// 		struct AadNewSramBlockDesc *next; // $a2
	// 		struct AadNewSramBlockDesc *sramDescTbl; // $t2
	// 		unsigned long safeWaveSize; // $t4
	// 		int i; // $a3
	// 		int sramDescIndex; // $t0
	// 		int bestFitIndex; // $t3
	/* end block 1 */
	// End offset: 0x8005313C
	// End Line: 1665

	/* begin block 2 */
		// Start line: 3724
	/* end block 2 */
	// End Line: 3725

	/* begin block 3 */
		// Start line: 3734
	/* end block 3 */
	// End Line: 3735

int aadWaveMalloc(ushort waveID,ulong waveSize)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  ushort uVar4;
  ushort *in_a2;
  ushort *puVar5;
  int in_a3;
  undefined uVar6;
  uint in_t0;
  ushort *in_t1;
  int in_t2;
  uint in_t3;
  uint in_t4;
  int in_t5;
  ushort in_t6;
  
  do {
    if ((in_t4 <= (uint)in_a2[2]) && ((in_t1 == (ushort *)0x0 || ((uint)in_a2[2] < (uint)in_t1[2])))
       ) {
      in_t1 = in_a2;
      in_t3 = in_t0;
    }
    do {
      if (*(char *)((int)in_a2 + 7) < '\0') {
        in_a2 = (ushort *)0x0;
      }
      else {
        uVar3 = (uint)*(byte *)((int)in_a2 + 7);
        in_a2 = (ushort *)0x0;
        if (uVar3 != in_t0) {
          in_a2 = (ushort *)(in_t2 + uVar3 * 8);
          in_t0 = uVar3;
        }
      }
      in_a3 = in_a3 + -1;
      if ((in_a2 == (ushort *)0x0) || (in_a3 == in_t5)) {
        if (in_t1 == (ushort *)0x0) {
          return 0xff;
        }
        *in_t1 = in_t6 | 0xc000;
        if (waveSize < (uint)in_t1[2]) {
          uVar4 = (ushort)waveSize;
          if (-1 < *(char *)((int)in_t1 + 7)) {
            puVar5 = (ushort *)(in_t2 + (uint)*(byte *)((int)in_t1 + 7) * 8);
            if ((*puVar5 & 0x4000) == 0) {
              puVar5[1] = puVar5[1] - (in_t1[2] - uVar4);
              puVar5[2] = puVar5[2] + (in_t1[2] - uVar4);
              in_t1[2] = uVar4;
              return in_t3;
            }
          }
          _uVar6 = aadMem->nextSramDescIndex;
          uVar6 = (undefined)_uVar6;
          puVar5 = (ushort *)(in_t2 + _uVar6 * 8);
          uVar2 = *puVar5;
          uVar3 = _uVar6;
          while ((uVar2 & 0x8000) != 0) {
            uVar3 = uVar3 + 1 & 0x7f;
            uVar6 = (undefined)uVar3;
            if (uVar3 == _uVar6) {
              return 0xff;
            }
            puVar5 = (ushort *)(in_t2 + uVar3 * 8);
            uVar2 = *puVar5;
          }
          aadMem->nextSramDescIndex = aadMem->nextSramDescIndex + 8U & 0x7f;
          *puVar5 = 0x8000;
          puVar5[1] = in_t1[1] + uVar4;
          uVar2 = in_t1[2];
          *(char *)(puVar5 + 3) = (char)in_t3;
          puVar5[2] = uVar2 - uVar4;
          bVar1 = *(byte *)((int)in_t1 + 7);
          *(byte *)((int)puVar5 + 7) = bVar1;
          if (-1 < (int)((uint)bVar1 << 0x18)) {
            *(undefined *)((uint)*(byte *)((int)puVar5 + 7) * 8 + in_t2 + 6) = uVar6;
          }
          in_t1[2] = uVar4;
          *(undefined *)((int)in_t1 + 7) = uVar6;
        }
        return in_t3;
      }
    } while ((*in_a2 & 0x4000) != 0);
  } while( true );
}



// decompiled code
// original method signature: 
// unsigned long /*$ra*/ aadGetSramBlockAddr(int handle /*$a0*/)
 // line 1669, offset 0x80053144
	/* begin block 1 */
		// Start line: 1671
		// Start offset: 0x80053144
		// Variables:
	// 		struct AadNewSramBlockDesc *sramDesc; // $v1
	/* end block 1 */
	// End offset: 0x80053168
	// End Line: 1681

	/* begin block 2 */
		// Start line: 3969
	/* end block 2 */
	// End Line: 3970

	/* begin block 3 */
		// Start line: 3970
	/* end block 3 */
	// End Line: 3971

	/* begin block 4 */
		// Start line: 3972
	/* end block 4 */
	// End Line: 3973

ulong aadGetSramBlockAddr(int handle)

{
  byte bVar1;
  int in_v0;
  ulong uVar2;
  undefined2 *in_a1;
  ushort *puVar3;
  int in_a3;
  
  puVar3 = (ushort *)(in_a3 + in_v0);
  if ((*puVar3 & 0x4000) == 0) {
    in_a1[2] = in_a1[2] + puVar3[2];
    bVar1 = *(byte *)((int)puVar3 + 7);
    *puVar3 = 0;
    *(byte *)((int)in_a1 + 7) = bVar1;
    if (-1 < (int)((uint)bVar1 << 0x18)) {
      *(undefined *)((uint)*(byte *)((int)in_a1 + 7) * 8 + in_a3 + 6) = (char)handle;
    }
  }
  uVar2 = SEXT14(*(char *)(in_a1 + 3));
  if (-1 < (int)uVar2) {
    puVar3 = (ushort *)(in_a3 + (uint)*(byte *)(in_a1 + 3) * 8);
    uVar2 = (uint)*puVar3 & 0x4000;
    if ((*puVar3 & 0x4000) == 0) {
      puVar3[2] = puVar3[2] + in_a1[2];
      bVar1 = *(byte *)((int)in_a1 + 7);
      *in_a1 = 0;
      *(byte *)((int)puVar3 + 7) = bVar1;
      uVar2 = (uint)bVar1 << 0x18;
      if (-1 < (int)uVar2) {
        uVar2 = (uint)*(byte *)((int)in_a1 + 7) * 8 + in_a3;
        *(undefined *)(uVar2 + 6) = *(undefined *)(in_a1 + 3);
      }
    }
  }
  return uVar2;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadWaveFree(int handle /*$a0*/)
 // line 1702, offset 0x80053170
	/* begin block 1 */
		// Start line: 1704
		// Start offset: 0x80053170
		// Variables:
	// 		struct AadNewSramBlockDesc *sramDesc; // $a1
	// 		struct AadNewSramBlockDesc *sramDescTbl; // $a3

		/* begin block 1.1 */
			// Start line: 1715
			// Start offset: 0x800531A0
			// Variables:
		// 		struct AadNewSramBlockDesc *next; // $a2
		/* end block 1.1 */
		// End offset: 0x80053204
		// End Line: 1724

		/* begin block 1.2 */
			// Start line: 1728
			// Start offset: 0x80053214
			// Variables:
		// 		struct AadNewSramBlockDesc *prev; // $a0
		/* end block 1.2 */
		// End offset: 0x80053278
		// End Line: 1737
	/* end block 1 */
	// End offset: 0x80053278
	// End Line: 1740

	/* begin block 2 */
		// Start line: 3404
	/* end block 2 */
	// End Line: 3405

	/* begin block 3 */
		// Start line: 4019
	/* end block 3 */
	// End Line: 4020

	/* begin block 4 */
		// Start line: 4022
	/* end block 4 */
	// End Line: 4023

void aadWaveFree(int handle)

{
  byte bVar1;
  ushort *puVar2;
  undefined2 *in_a1;
  undefined2 *in_a2;
  int in_a3;
  
  bVar1 = *(byte *)((int)in_a2 + 7);
  *in_a2 = 0;
  *(byte *)((int)in_a1 + 7) = bVar1;
  if (-1 < (int)((uint)bVar1 << 0x18)) {
    *(undefined *)((uint)*(byte *)((int)in_a1 + 7) * 8 + in_a3 + 6) = (char)handle;
  }
  if ((-1 < *(char *)(in_a1 + 3)) &&
     (puVar2 = (ushort *)(in_a3 + (uint)*(byte *)(in_a1 + 3) * 8), (*puVar2 & 0x4000) == 0)) {
    puVar2[2] = puVar2[2] + in_a1[2];
    bVar1 = *(byte *)((int)in_a1 + 7);
    *in_a1 = 0;
    *(byte *)((int)puVar2 + 7) = bVar1;
    if (-1 < (int)((uint)bVar1 << 0x18)) {
      *(undefined *)((uint)*(byte *)((int)in_a1 + 7) * 8 + in_a3 + 6) = *(undefined *)(in_a1 + 3);
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadFreeSingleDynSfx(int sfxID /*$a0*/)
 // line 1744, offset 0x80053280
	/* begin block 1 */
		// Start line: 1745
		// Start offset: 0x80053280
		// Variables:
	// 		int ti; // $v1
	// 		int wi; // $v1
	// 		struct AadLoadedSfxToneAttr *toneAttr; // $a1
	// 		struct AadLoadedSfxWaveAttr *waveAttr; // $v1
	/* end block 1 */
	// End offset: 0x80053338
	// End Line: 1770

	/* begin block 2 */
		// Start line: 4106
	/* end block 2 */
	// End Line: 4107

	/* begin block 3 */
		// Start line: 4111
	/* end block 3 */
	// End Line: 4112

void aadFreeSingleDynSfx(int sfxID)

{
  short sVar1;
  int in_v1;
  short *psVar2;
  int in_a1;
  undefined in_a2;
  
  if (in_v1 < 0xfe) {
    psVar2 = (short *)(&DAT_00001608 + sfxID + in_v1 * 4);
    sVar1 = *psVar2;
    *psVar2 = sVar1 + -1;
    if ((short)(sVar1 + -1) == 0) {
      *(undefined *)(sfxID + (uint)*(ushort *)(in_a1 + 2) + 0xa08) = in_a2;
      FUN_80053108((uint)*(byte *)((int)psVar2 + 3));
    }
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ setSramFullAlarm()
 // line 1773, offset 0x80053348
	/* begin block 1 */
		// Start line: 1775
		// Start offset: 0x80053348
		// Variables:
	// 		struct AadNewSramBlockDesc *sramDescTbl; // $v1
	// 		struct AadNewSramBlockDesc *sramDesc; // $a1
	// 		long totalUsed; // $t0
	// 		long totalFree; // $t1
	// 		long largestFree; // $t2
	// 		long numFreeBlocks; // $t3
	// 		long numUsedBlocks; // $a3
	// 		int i; // $a2
	/* end block 1 */
	// End offset: 0x800533F4
	// End Line: 1812

	/* begin block 2 */
		// Start line: 4169
	/* end block 2 */
	// End Line: 4170

	/* begin block 3 */
		// Start line: 4170
	/* end block 3 */
	// End Line: 4171

	/* begin block 4 */
		// Start line: 4184
	/* end block 4 */
	// End Line: 4185

/* WARNING: Unknown calling convention yet parameter storage is locked */

void setSramFullAlarm(void)

{
  int in_v1;
  uint in_a0;
  ushort *in_a1;
  int in_a2;
  int in_a3;
  int in_t0;
  int in_t1;
  int iVar1;
  int in_t3;
  
  iVar1 = in_t1 + in_a0;
  while( true ) {
    if (*(char *)((int)in_a1 + 7) < '\0') {
      in_a1 = (ushort *)0x0;
    }
    else {
      in_a1 = (ushort *)(in_v1 + (uint)*(byte *)((int)in_a1 + 7) * 8);
    }
    in_a2 = in_a2 + -1;
    if ((in_a2 == 0) || (in_a1 == (ushort *)0x0)) break;
    if ((*in_a1 & 0x4000) == 0) {
      in_a0 = (uint)in_a1[2];
      in_t3 = in_t3 + 1;
      iVar1 = iVar1 + in_a0;
    }
    else {
      in_a3 = in_a3 + 1;
      in_t0 = in_t0 + (uint)in_a1[2];
    }
  }
  gSramFullAlarm = 1;
  gameTrackerX.fps30Count = in_a0 << 3;
  soundEffectChannelTbl[2]._24_4_ = in_t3;
  soundEffectChannelTbl[2]._28_4_ = in_a3;
  soundEffectChannelTbl[2]._32_4_ = in_t0 << 3;
  soundEffectChannelTbl[3]._0_4_ = iVar1 << 3;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadLoadSingleDynSfx(struct AadDynamicSfxLoadInfo *info /*$s2*/)
 // line 1829, offset 0x80053424
	/* begin block 1 */
		// Start line: 1830
		// Start offset: 0x80053424
		// Variables:
	// 		int i; // $a0
	// 		struct AadLoadedSfxToneAttr *toneAttr; // $a1
	// 		struct AadLoadedSfxWaveAttr *waveAttr; // $s0
	// 		struct AadDynSfxAttr *attr; // $s1
	/* end block 1 */
	// End offset: 0x800536DC
	// End Line: 1943

	/* begin block 2 */
		// Start line: 4288
	/* end block 2 */
	// End Line: 4289

	/* begin block 3 */
		// Start line: 4297
	/* end block 3 */
	// End Line: 4298

void aadLoadSingleDynSfx(AadDynamicSfxLoadInfo *info)

{
  int in_v0;
  int in_v1;
  short *psVar1;
  int unaff_s2;
  
  psVar1 = (short *)(in_v1 + in_v0 + 0xc08);
  *psVar1 = *psVar1 + 1;
  *(undefined4 *)(unaff_s2 + 0x60) = 2;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ HackCallback()
 // line 1958, offset 0x800536f4
	/* begin block 1 */
		// Start line: 4622
	/* end block 1 */
	// End Line: 4623

/* WARNING: Unknown calling convention yet parameter storage is locked */

void HackCallback(void)

{
  uint uVar1;
  int iVar2;
  int unaff_s1;
  uint unaff_s2;
  int unaff_s3;
  int *unaff_s4;
  
  if (unaff_s2 != 0) {
    do {
      iVar2 = *(int *)(unaff_s1 + 0x60);
      if (iVar2 == 1) {
        iVar2 = (int)unaff_s4 + unaff_s3;
        uVar1 = *(uint *)(unaff_s1 + 100);
        if (unaff_s2 < *(uint *)(unaff_s1 + 100)) {
          uVar1 = unaff_s2;
        }
        unaff_s3 = unaff_s3 + uVar1;
        FUN_8007919c(unaff_s1 - (*(int *)(unaff_s1 + 100) + -0x94),iVar2,uVar1);
        unaff_s2 = unaff_s2 - uVar1;
        iVar2 = *(int *)(unaff_s1 + 100) - uVar1;
        *(int *)(unaff_s1 + 100) = iVar2;
        if (iVar2 == 0) {
          FUN_800533bc();
          *(undefined4 *)(unaff_s1 + 100) = *(undefined4 *)(unaff_s1 + 0x90);
        }
      }
      else {
        if (iVar2 < 2) {
          if (iVar2 == 0) {
            iVar2 = FUN_80051ed0(0x61,0x53,0x4d,0x46);
            if (*unaff_s4 != iVar2) {
              FUN_80052c90();
              return;
            }
            if (*(short *)(unaff_s4 + 1) != 0x100) {
              FUN_80052c90();
              return;
            }
            if (*(short *)((int)unaff_s4 + 6) != *(short *)(*(int *)(unaff_s1 + 0x78) + 6)) {
LAB_800537c4:
              FUN_80052c90();
              return;
            }
            uVar1 = (uint)*(ushort *)(*(int *)(unaff_s1 + 0x78) + 10);
            unaff_s3 = unaff_s3 + 0x10;
            if ((uint)*(ushort *)(unaff_s4 + 2) != uVar1) goto LAB_800537c4;
            unaff_s2 = unaff_s2 - 0x10;
            *(undefined4 *)(unaff_s1 + 0x60) = 1;
            *(undefined4 *)(unaff_s1 + 100) = 0x18;
            *(uint *)(unaff_s1 + 0x68) = uVar1;
          }
        }
        else {
          if (iVar2 == 2) {
            uVar1 = *(uint *)(unaff_s1 + 100);
            if (unaff_s2 < *(uint *)(unaff_s1 + 100)) {
              uVar1 = unaff_s2;
            }
            unaff_s3 = unaff_s3 + uVar1;
            unaff_s2 = unaff_s2 - uVar1;
            iVar2 = *(int *)(unaff_s1 + 100) - uVar1;
            *(int *)(unaff_s1 + 100) = iVar2;
            if (iVar2 == 0) {
              iVar2 = *(int *)(unaff_s1 + 0x68) + -1;
              *(int *)(unaff_s1 + 0x68) = iVar2;
              if (iVar2 == 0) {
LAB_80053920:
                FUN_80052d14();
                return;
              }
              *(undefined4 *)(unaff_s1 + 0x60) = 1;
              *(undefined4 *)(unaff_s1 + 100) = 0x18;
            }
          }
          else {
            if (iVar2 == 3) {
              uVar1 = *(uint *)(unaff_s1 + 100);
              if (unaff_s2 < *(uint *)(unaff_s1 + 100)) {
                uVar1 = unaff_s2;
              }
              unaff_s2 = unaff_s2 - uVar1;
              FUN_80053f7c();
              FUN_800c0484(FUN_8005368c);
              FUN_800bfe58(*(undefined4 *)(unaff_s1 + 0x70));
              FUN_800bfeb8((int)unaff_s4 + unaff_s3,uVar1);
              unaff_s3 = unaff_s3 + uVar1;
              iVar2 = *(int *)(unaff_s1 + 100) - uVar1;
              *(int *)(unaff_s1 + 0x70) = *(int *)(unaff_s1 + 0x70) + uVar1;
              *(int *)(unaff_s1 + 100) = iVar2;
              if (iVar2 == 0) {
                iVar2 = *(int *)(unaff_s1 + 0x68) + -1;
                *(int *)(unaff_s1 + 0x74) = *(int *)(unaff_s1 + 0x74) + *(int *)(unaff_s1 + 0x90);
                *(int *)(unaff_s1 + 0x68) = iVar2;
                if (iVar2 == 0) {
                  FUN_800c0484(0);
                  goto LAB_80053920;
                }
                *(undefined4 *)(unaff_s1 + 0x60) = 1;
                *(undefined4 *)(unaff_s1 + 100) = 0x18;
              }
              if (unaff_s2 != 0) {
                DVECTOR_800d170c = (int)unaff_s4 + unaff_s3;
                DVECTOR_800d1710 = unaff_s2;
                DVECTOR_ARRAY_800d1714[0] = unaff_s1;
                return;
              }
              FUN_800c0484(0);
            }
          }
        }
      }
    } while (unaff_s2 != 0);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadLoadDynamicSfxReturn2(void *loadedDataPtr /*$a0*/, long loadedDataSize /*$a1*/, short status /*$a2*/, void *data1 /*$a3*/, void *data2 /*stack 16*/)
 // line 1967, offset 0x8005372c
	/* begin block 1 */
		// Start line: 1968
		// Start offset: 0x8005372C
		// Variables:
	// 		unsigned char *dataPtr; // $s4
	// 		unsigned long dataOffset; // $s3
	// 		unsigned long bytesRemaining; // $s2
	// 		struct AadDynamicSfxLoadInfo *info; // $s1
	// 		unsigned long n; // $s0
	/* end block 1 */
	// End offset: 0x800539CC
	// End Line: 2120

	/* begin block 2 */
		// Start line: 4640
	/* end block 2 */
	// End Line: 4641

void aadLoadDynamicSfxReturn2
               (void *loadedDataPtr,long loadedDataSize,short status,void *data1,void *data2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  int in_v1;
  int unaff_s1;
  uint unaff_s2;
  int unaff_s3;
  int *unaff_s4;
  int unaff_s5;
  undefined4 unaff_s6;
  
code_r0x8005372c:
  if (in_v1 == 2) {
    uVar4 = *(uint *)(unaff_s1 + 100);
    if (unaff_s2 < *(uint *)(unaff_s1 + 100)) {
      uVar4 = unaff_s2;
    }
    unaff_s3 = unaff_s3 + uVar4;
    unaff_s2 = unaff_s2 - uVar4;
    iVar3 = *(int *)(unaff_s1 + 100) - uVar4;
    *(int *)(unaff_s1 + 100) = iVar3;
    if (iVar3 != 0) goto LAB_8005395c;
    iVar3 = *(int *)(unaff_s1 + 0x68) + -1;
    *(int *)(unaff_s1 + 0x68) = iVar3;
    if (iVar3 != 0) {
      *(int *)(unaff_s1 + 0x60) = unaff_s5;
      *(undefined4 *)(unaff_s1 + 100) = unaff_s6;
      goto LAB_8005395c;
    }
LAB_80053920:
    FUN_80052d14();
    iVar3 = DVECTOR_800d170c;
    iVar1 = DVECTOR_800d1710;
    iVar2 = DVECTOR_ARRAY_800d1714[0];
  }
  else {
    if (in_v1 != 3) goto LAB_8005395c;
    uVar4 = *(uint *)(unaff_s1 + 100);
    if (unaff_s2 < *(uint *)(unaff_s1 + 100)) {
      uVar4 = unaff_s2;
    }
    unaff_s2 = unaff_s2 - uVar4;
    FUN_80053f7c();
    FUN_800c0484(FUN_8005368c);
    FUN_800bfe58(*(undefined4 *)(unaff_s1 + 0x70));
    FUN_800bfeb8((int)unaff_s4 + unaff_s3,uVar4);
    unaff_s3 = unaff_s3 + uVar4;
    iVar3 = *(int *)(unaff_s1 + 100) - uVar4;
    *(int *)(unaff_s1 + 0x70) = *(int *)(unaff_s1 + 0x70) + uVar4;
    *(int *)(unaff_s1 + 100) = iVar3;
    if (iVar3 == 0) {
      iVar3 = *(int *)(unaff_s1 + 0x68) + -1;
      *(int *)(unaff_s1 + 0x74) = *(int *)(unaff_s1 + 0x74) + *(int *)(unaff_s1 + 0x90);
      *(int *)(unaff_s1 + 0x68) = iVar3;
      if (iVar3 == 0) {
        FUN_800c0484(0);
        goto LAB_80053920;
      }
      *(int *)(unaff_s1 + 0x60) = unaff_s5;
      *(undefined4 *)(unaff_s1 + 100) = unaff_s6;
    }
    iVar3 = (int)unaff_s4 + unaff_s3;
    iVar1 = unaff_s2;
    iVar2 = unaff_s1;
    if (unaff_s2 == 0) {
      FUN_800c0484(0);
LAB_8005395c:
      do {
        while( true ) {
          if (unaff_s2 == 0) {
            return;
          }
          in_v1 = *(int *)(unaff_s1 + 0x60);
          if (in_v1 != unaff_s5) break;
          iVar3 = (int)unaff_s4 + unaff_s3;
          uVar4 = *(uint *)(unaff_s1 + 100);
          if (unaff_s2 < *(uint *)(unaff_s1 + 100)) {
            uVar4 = unaff_s2;
          }
          unaff_s3 = unaff_s3 + uVar4;
          FUN_8007919c(unaff_s1 - (*(int *)(unaff_s1 + 100) + -0x94),iVar3,uVar4);
          unaff_s2 = unaff_s2 - uVar4;
          iVar3 = *(int *)(unaff_s1 + 100) - uVar4;
          *(int *)(unaff_s1 + 100) = iVar3;
          if (iVar3 == 0) {
            FUN_800533bc();
            *(undefined4 *)(unaff_s1 + 100) = *(undefined4 *)(unaff_s1 + 0x90);
          }
        }
        if (1 < in_v1) goto code_r0x8005372c;
        if (in_v1 == 0) {
          iVar3 = FUN_80051ed0(0x61,0x53,0x4d,0x46);
          if (*unaff_s4 != iVar3) {
            FUN_80052c90();
            return;
          }
          if (*(short *)(unaff_s4 + 1) != 0x100) {
            FUN_80052c90();
            return;
          }
          if (*(short *)((int)unaff_s4 + 6) == *(short *)(*(int *)(unaff_s1 + 0x78) + 6)) {
            uVar4 = (uint)*(ushort *)(*(int *)(unaff_s1 + 0x78) + 10);
            unaff_s3 = unaff_s3 + 0x10;
            if ((uint)*(ushort *)(unaff_s4 + 2) == uVar4) {
              unaff_s2 = unaff_s2 - 0x10;
              *(int *)(unaff_s1 + 0x60) = unaff_s5;
              *(undefined4 *)(unaff_s1 + 100) = unaff_s6;
              *(uint *)(unaff_s1 + 0x68) = uVar4;
              goto LAB_8005395c;
            }
          }
          FUN_80052c90();
          return;
        }
      } while( true );
    }
  }
  DVECTOR_ARRAY_800d1714[0] = iVar2;
  DVECTOR_800d1710 = iVar1;
  DVECTOR_800d170c = iVar3;
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadCheckSramFragmented()
 // line 2172, offset 0x800539f4
	/* begin block 1 */
		// Start line: 2174
		// Start offset: 0x800539F4
		// Variables:
	// 		struct AadNewSramBlockDesc *sramDescTbl; // $v1
	// 		struct AadNewSramBlockDesc *sramDesc; // $a1
	// 		long totalFree; // $t0
	// 		long smallestFree; // $t1
	// 		long numFreeBlocks; // $a3
	// 		int i; // $a2
	// 		int defragNeeded; // $v1
	/* end block 1 */
	// End offset: 0x80053AA0
	// End Line: 2216

	/* begin block 2 */
		// Start line: 5103
	/* end block 2 */
	// End Line: 5104

	/* begin block 3 */
		// Start line: 5104
	/* end block 3 */
	// End Line: 5105

	/* begin block 4 */
		// Start line: 5114
	/* end block 4 */
	// End Line: 5115

/* WARNING: Unknown calling convention yet parameter storage is locked */

int aadCheckSramFragmented(void)

{
  int in_v1;
  uint uVar1;
  ushort *in_a1;
  int in_a2;
  int in_a3;
  int in_t0;
  uint in_t1;
  
  do {
    in_a1 = (ushort *)(in_v1 + (uint)*(byte *)((int)in_a1 + 7) * 8);
    while( true ) {
      in_a2 = in_a2 + -1;
      if ((in_a2 == 0) || (in_a1 == (ushort *)0x0)) {
        uVar1 = 0;
        if (2 < in_a3) {
          uVar1 = (uint)((int)in_t1 < in_t0 >> 2);
        }
        return uVar1;
      }
      if ((*in_a1 & 0x4000) == 0) {
        uVar1 = (uint)in_a1[2];
        in_a3 = in_a3 + 1;
        in_t0 = in_t0 + uVar1;
        if ((int)uVar1 < (int)in_t1) {
          in_t1 = uVar1;
        }
      }
      if (-1 < *(char *)((int)in_a1 + 7)) break;
      in_a1 = (ushort *)0x0;
    }
  } while( true );
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadProcessSramDefrag()
 // line 2235, offset 0x80053aa8
	/* begin block 1 */
		// Start line: 2236
		// Start offset: 0x80053AA8
		// Variables:
	// 		struct AadSramDefragInfo *info; // $s3
	// 		struct AadNewSramBlockDesc *sramDescTbl; // $s5
	// 		struct AadNewSramBlockDesc *firstBlock; // $s1
	// 		struct AadNewSramBlockDesc *secondBlock; // $s2
	// 		int n; // $s0
	// 		int waveID; // $a0
	// 		int firstBlockIndex; // $s4
	// 		int secondBlockIndex; // $s6

		/* begin block 1.1 */
			// Start line: 2338
			// Start offset: 0x80053C70
			// Variables:
		// 		struct AadNewSramBlockDesc *next; // $a0
		/* end block 1.1 */
		// End offset: 0x80053CD4
		// End Line: 2350
	/* end block 1 */
	// End offset: 0x80053DE4
	// End Line: 2428

	/* begin block 2 */
		// Start line: 5234
	/* end block 2 */
	// End Line: 5235

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadProcessSramDefrag(void)

{
  byte bVar1;
  ushort uVar2;
  AadMemoryStruct *pAVar3;
  int iVar4;
  int iVar5;
  int unaff_s1;
  ushort *puVar6;
  int iVar7;
  ushort *puVar8;
  undefined4 *unaff_s4;
  byte bVar9;
  uint uVar10;
  int iVar11;
  undefined uStack00000010;
  uint uStack00000010_00;
  
  uVar10 = *(uint *)(&DAT_00001bf4 + unaff_s1);
  iVar11 = unaff_s1 + 0x17f0;
  puVar6 = (ushort *)(iVar11 + uVar10 * 8);
  iVar5 = 0x80;
  if (puVar6 != (ushort *)0x0) {
    do {
      bVar9 = (byte)uVar10;
      if ((*puVar6 & 0x4000) == 0) break;
      iVar5 = iVar5 + -1;
      bVar9 = *(byte *)((int)puVar6 + 7);
      uVar10 = (uint)bVar9;
      if ((iVar5 == 0) || (0x7f < bVar9)) {
        puVar6 = (ushort *)0x0;
      }
      else {
        puVar6 = (ushort *)(iVar11 + uVar10 * 8);
      }
    } while (puVar6 != (ushort *)0x0);
    if ((puVar6 != (ushort *)0x0) && (-1 < *(char *)((int)puVar6 + 7))) {
      uStack00000010_00 = (uint)*(byte *)((int)puVar6 + 7);
      puVar8 = (ushort *)(iVar11 + uStack00000010_00 * 8);
      if ((*puVar8 & 0x4000) != 0) {
        iVar5 = (*aadMem->memoryMallocProc)(0x1000,0x30);
        unaff_s4[1] = iVar5;
        pAVar3 = aadMem;
        if (iVar5 != 0) {
          uVar10 = (uint)*puVar8 & 0x3fff;
          iVar5 = (int)&aadMem->updateCounter + uVar10;
          bVar1 = *(byte *)(iVar5 + 0xa08);
          unaff_s4[2] = (uint)bVar1;
          if (bVar1 < 0xfe) {
            *(undefined *)(iVar5 + 0xa08) = 0xff;
            iVar5 = 0;
            iVar7 = 0x1dc;
            do {
              iVar4 = (int)&aadMem->updateCounter + iVar7;
              if ((((*(char *)(iVar4 + 8) == -0x30) && (aadMem->voiceStatus[iVar5] != '\0')) &&
                  (aadMem->voiceStatus[iVar5] != '\x02')) &&
                 ((uint)*(ushort *)(*(int *)(iVar4 + 0x14) + -2) == uVar10)) {
                FUN_80056a68(*(undefined4 *)(iVar4 + 4));
              }
              iVar5 = iVar5 + 1;
              iVar7 = iVar7 + 0x1c;
            } while (iVar5 < 0x18);
            unaff_s4[3] = uVar10;
            unaff_s4[4] = (uint)puVar6[1] << 3;
            unaff_s4[5] = (uint)puVar8[1] << 3;
            unaff_s4[6] = (uint)puVar8[2] << 3;
            uVar2 = puVar6[2];
            puVar6[2] = puVar8[2];
            puVar8[2] = uVar2;
            uVar2 = *puVar6;
            *puVar6 = *puVar8;
            *puVar8 = uVar2;
            puVar8[1] = puVar6[1] + puVar6[2];
            if ((-1 < *(char *)((int)puVar8 + 7)) &&
               (puVar6 = (ushort *)(iVar11 + (uint)*(byte *)((int)puVar8 + 7) * 8),
               (*puVar6 & 0x4000) == 0)) {
              puVar8[2] = puVar8[2] + puVar6[2];
              bVar1 = *(byte *)((int)puVar6 + 7);
              *puVar6 = 0;
              *(byte *)((int)puVar8 + 7) = bVar1;
              if (-1 < (int)((uint)bVar1 << 0x18)) {
                *(undefined *)((uint)*(byte *)((int)puVar8 + 7) * 8 + iVar11 + 6) = uStack00000010;
              }
            }
            aadMem->sfxWaveAttrTbl[unaff_s4[2]].sramHandle = bVar9;
            *unaff_s4 = 2;
            return;
          }
          (*pAVar3->memoryFreeProc)(unaff_s4[1]);
        }
      }
    }
  }
  *unaff_s4 = 0;
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadIsSfxLoaded(unsigned int toneID /*$a0*/)
 // line 2437, offset 0x80053e0c
	/* begin block 1 */
		// Start line: 4874
	/* end block 1 */
	// End Line: 4875

	/* begin block 2 */
		// Start line: 5664
	/* end block 2 */
	// End Line: 5665

int aadIsSfxLoaded(uint toneID)

{
  int in_v0;
  
  return in_v0;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadInitSequenceSlot(struct _AadSequenceSlot *slot /*$a2*/)
 // line 2710, offset 0x80053e48
	/* begin block 1 */
		// Start line: 2711
		// Start offset: 0x80053E48
		// Variables:
	// 		struct AadSequenceHdr *seqHdr; // $t0
	// 		unsigned long trackOffset; // $v0
	// 		int i; // $a1
	// 		int bank; // $a0
	/* end block 1 */
	// End offset: 0x80053F38
	// End Line: 2769

	/* begin block 2 */
		// Start line: 5946
	/* end block 2 */
	// End Line: 5947

	/* begin block 3 */
		// Start line: 6211
	/* end block 3 */
	// End Line: 6212

void aadInitSequenceSlot(_AadSequenceSlot *slot)

{
  if (((_AadSequenceSlot *)0xfd < slot) && (slot != (_AadSequenceSlot *)0xfe)) {
    return;
  }
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadWaitForSramTransferComplete()
 // line 2779, offset 0x80053f54
	/* begin block 1 */
		// Start line: 2780
		// Start offset: 0x80053F54
		// Variables:
	// 		int n; // $s0
	/* end block 1 */
	// End offset: 0x80053F84
	// End Line: 2787

	/* begin block 2 */
		// Start line: 6438
	/* end block 2 */
	// End Line: 6439

/* WARNING: Unknown calling convention yet parameter storage is locked */

int aadWaitForSramTransferComplete(void)

{
  undefined uVar1;
  int iVar2;
  int in_a0;
  int in_a1;
  int in_a2;
  undefined2 in_a3;
  undefined in_t0;
  undefined in_t1;
  undefined in_t2;
  
  while (in_a1 < 0x10) {
    iVar2 = in_a2 + in_a1;
    uVar1 = *(undefined *)(in_a2 + 0x55c);
    in_a1 = in_a1 + 1;
    *(undefined *)(iVar2 + 0x590) = in_t2;
    *(undefined *)(iVar2 + 0x5a0) = in_t1;
    *(undefined *)(iVar2 + 0x5b0) = in_t0;
    *(undefined *)(iVar2 + 0x560) = uVar1;
    *(undefined2 *)(in_a0 + 0x572) = in_a3;
    in_a0 = in_a0 + 2;
  }
  *(int *)(in_a2 + 0x538) = in_a2;
  *(undefined2 *)(in_a2 + 0x544) = 0;
  *(undefined2 *)(in_a2 + 0x546) = 0;
  *(undefined2 *)(in_a2 + 0x548) = 0;
  *(byte *)(in_a2 + 0x53c) = *(byte *)(in_a2 + 0x53f);
  return (uint)*(byte *)(in_a2 + 0x53f);
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadInitReverb()
 // line 2790, offset 0x80053f94
	/* begin block 1 */
		// Start line: 6461
	/* end block 1 */
	// End Line: 6462

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadInitReverb(void)

{
  int in_v0;
  int unaff_s0;
  
  while ((in_v0 == 0 && (unaff_s0 = unaff_s0 + -1, unaff_s0 != 0))) {
    in_v0 = FUN_800bf5c8(0);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadShutdownReverb()
 // line 2806, offset 0x80054018
	/* begin block 1 */
		// Start line: 6493
	/* end block 1 */
	// End Line: 6494

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadShutdownReverb(void)

{
  FUN_800bff18();
  FUN_800c04e4(1);
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadGetReverbMode()
 // line 2820, offset 0x80054050
	/* begin block 1 */
		// Start line: 6521
	/* end block 1 */
	// End Line: 6522

	/* begin block 2 */
		// Start line: 6522
	/* end block 2 */
	// End Line: 6523

/* WARNING: Unknown calling convention yet parameter storage is locked */

int aadGetReverbMode(void)

{
  int in_v0;
  undefined4 uVar1;
  
  if (in_v0 != 0) {
    uVar1 = FUN_80054078();
    in_v0 = FUN_800c0264(uVar1);
  }
  return in_v0;
}



// decompiled code
// original method signature: 
// unsigned long /*$ra*/ aadGetReverbSize()
 // line 2842, offset 0x80054058
	/* begin block 1 */
		// Start line: 6565
	/* end block 1 */
	// End Line: 6566

/* WARNING: Unknown calling convention yet parameter storage is locked */

ulong aadGetReverbSize(void)

{
  undefined4 uVar1;
  ulong uVar2;
  
  uVar1 = FUN_80054078();
  uVar2 = FUN_800c0264(uVar1);
  return uVar2;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadGetReverbDepth()
 // line 2847, offset 0x80054088
	/* begin block 1 */
		// Start line: 6575
	/* end block 1 */
	// End Line: 6576

	/* begin block 2 */
		// Start line: 6576
	/* end block 2 */
	// End Line: 6577

/* WARNING: Unknown calling convention yet parameter storage is locked */

int aadGetReverbDepth(void)

{
  int iVar1;
  
  iVar1 = FUN_80054078();
  return aadReverbModeSize[iVar1] + 0x40;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadGetNumDynamicSequences(int bank /*$a0*/)
 // line 2860, offset 0x80054090
	/* begin block 1 */
		// Start line: 5720
	/* end block 1 */
	// End Line: 5721

	/* begin block 2 */
		// Start line: 6592
	/* end block 2 */
	// End Line: 6593

int aadGetNumDynamicSequences(int bank)

{
  int in_v0;
  
  return aadReverbModeSize[in_v0] + 0x40;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadAssignDynamicSequence(int bank /*$s1*/, int sequenceNumber /*$s3*/, int slotNumber /*$s2*/)
 // line 2877, offset 0x800540c0
	/* begin block 1 */
		// Start line: 2878
		// Start offset: 0x800540C0
		// Variables:
	// 		struct AadTempo tempo; // stack offset -32
	// 		struct _AadSequenceSlot *slot; // $s0
	// 		int i; // $v1
	/* end block 1 */
	// End offset: 0x80054180
	// End Line: 2924

	/* begin block 2 */
		// Start line: 6623
	/* end block 2 */
	// End Line: 6624

int aadAssignDynamicSequence(int bank,int sequenceNumber,int slotNumber)

{
  int in_v0;
  int iVar1;
  
  iVar1 = 0;
  if (*(int *)(in_v0 + bank + 0x500) == 2) {
    iVar1 = *(int *)(*(int *)(in_v0 + bank + 0x4d0) + 0x18);
  }
  return iVar1;
}



// decompiled code
// original method signature: 
// struct AadTempo * /*$ra*/ aadGetTempoFromDynamicSequence(int bank /*$a0*/, int sequenceNumber /*$a1*/, struct AadTempo *tempo /*$a2*/)
 // line 2927, offset 0x8005419c
	/* begin block 1 */
		// Start line: 2929
		// Start offset: 0x8005419C
		// Variables:
	// 		struct AadSequenceHdr *seqHdr; // $v1
	/* end block 1 */
	// End offset: 0x800541E4
	// End Line: 2942

	/* begin block 2 */
		// Start line: 6753
	/* end block 2 */
	// End Line: 6754

	/* begin block 3 */
		// Start line: 6754
	/* end block 3 */
	// End Line: 6755

	/* begin block 4 */
		// Start line: 6761
	/* end block 4 */
	// End Line: 6762

AadTempo * aadGetTempoFromDynamicSequence(int bank,int sequenceNumber,AadTempo *tempo)

{
  int in_v0;
  int in_v1;
  
  while (-1 < in_v1) {
    *(undefined *)(in_v0 + 0x5bf) = 0;
    in_v1 = in_v1 + -1;
    in_v0 = in_v0 + -1;
  }
  return (AadTempo *)0x0;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadSetSlotTempo(int slotNumber /*$a0*/, struct AadTempo *tempo /*$a1*/)
 // line 3061, offset 0x800541ec
	/* begin block 1 */
		// Start line: 3063
		// Start offset: 0x800541EC
		// Variables:
	// 		struct _AadSequenceSlot *slot; // $a0
	// 		unsigned long tickTime; // $v1
	// 		unsigned long tickTimeRemainder; // $a2
	/* end block 1 */
	// End offset: 0x800541EC
	// End Line: 3069

	/* begin block 2 */
		// Start line: 7021
	/* end block 2 */
	// End Line: 7022

	/* begin block 3 */
		// Start line: 7022
	/* end block 3 */
	// End Line: 7023

	/* begin block 4 */
		// Start line: 7028
	/* end block 4 */
	// End Line: 7029

void aadSetSlotTempo(int slotNumber,AadTempo *tempo)

{
  int *in_v0;
  int iVar1;
  undefined4 *in_a2;
  
  iVar1 = *in_v0;
  *in_a2 = *(undefined4 *)(iVar1 + 4);
  in_a2[1] = (uint)*(ushort *)(iVar1 + 8);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadStartSlot(int slotNumber /*$a0*/)
 // line 3082, offset 0x800542a0
	/* begin block 1 */
		// Start line: 3083
		// Start offset: 0x800542A0
		// Variables:
	// 		struct _AadSequenceSlot *slot; // $s0
	/* end block 1 */
	// End offset: 0x8005430C
	// End Line: 3096

	/* begin block 2 */
		// Start line: 7068
	/* end block 2 */
	// End Line: 7069

	/* begin block 3 */
		// Start line: 7071
	/* end block 3 */
	// End Line: 7072

void aadStartSlot(int slotNumber)

{
  uint in_v0;
  uint in_v1;
  undefined4 *in_a1;
  
  *(uint *)(slotNumber + 0xc) = in_v0 % in_v1;
  *(undefined4 *)(slotNumber + 0x14) = *in_a1;
  *(undefined2 *)(slotNumber + 0x12) = *(undefined2 *)(in_a1 + 1);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadStopSlot(int slotNumber /*$s0*/)
 // line 3099, offset 0x8005431c
	/* begin block 1 */
		// Start line: 3100
		// Start offset: 0x8005431C
		// Variables:
	// 		struct _AadSequenceSlot *slot; // $a0
	/* end block 1 */
	// End offset: 0x80054378
	// End Line: 3114

	/* begin block 2 */
		// Start line: 7105
	/* end block 2 */
	// End Line: 7106

	/* begin block 3 */
		// Start line: 7108
	/* end block 3 */
	// End Line: 7109

void aadStopSlot(int slotNumber)

{
  int unaff_s0;
  
  FUN_80053e70();
  *(ushort *)(unaff_s0 + 0x540) = *(ushort *)(unaff_s0 + 0x540) | 1;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadStopAllSlots()
 // line 3117, offset 0x80054388
	/* begin block 1 */
		// Start line: 3118
		// Start offset: 0x80054388
		// Variables:
	// 		struct _AadSequenceSlot *slot; // $s1
	// 		int slotNumber; // $s0
	/* end block 1 */
	// End offset: 0x80054400
	// End Line: 3132

	/* begin block 2 */
		// Start line: 7147
	/* end block 2 */
	// End Line: 7148

	/* begin block 3 */
		// Start line: 7152
	/* end block 3 */
	// End Line: 7153

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadStopAllSlots(void)

{
  undefined4 in_v0;
  int in_a0;
  
  *(ushort *)(in_a0 + 0x540) = (ushort)in_v0 & 0xfffe;
  FUN_80053e70();
  FUN_800545b0();
  return;
}



// autogenerated function stub: 
// void /*$ra*/ aadDisableSlot(int slotNumber /*$a0*/)
void aadDisableSlot(int slotNumber)
{ // line 3135, offset 0x80054418
	/* begin block 1 */
		// Start line: 7194
	/* end block 1 */
	// End Line: 7195

	/* begin block 2 */
		// Start line: 7195
	/* end block 2 */
	// End Line: 7196

}


// decompiled code
// original method signature: 
// void /*$ra*/ aadEnableSlot(int slotNumber /*$a0*/)
 // line 3146, offset 0x80054468
	/* begin block 1 */
		// Start line: 7217
	/* end block 1 */
	// End Line: 7218

	/* begin block 2 */
		// Start line: 7218
	/* end block 2 */
	// End Line: 7219

void aadEnableSlot(int slotNumber)

{
  int in_v1;
  
  *(byte *)(in_v1 + 0x550) = *(byte *)(in_v1 + 0x550) | 1;
  FUN_800545b0();
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadPauseSlot(int slotNumber /*$a0*/)
 // line 3154, offset 0x800544a8
	/* begin block 1 */
		// Start line: 7233
	/* end block 1 */
	// End Line: 7234

	/* begin block 2 */
		// Start line: 7234
	/* end block 2 */
	// End Line: 7235

void aadPauseSlot(int slotNumber)

{
  int in_v1;
  int iVar1;
  
  iVar1 = *(int *)(in_v1 + slotNumber * 4 + 0x34);
  *(byte *)(iVar1 + 0x550) = *(byte *)(iVar1 + 0x550) & 0xfe;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadResumeSlot(int slotNumber /*$a0*/)
 // line 3165, offset 0x800544f8
	/* begin block 1 */
		// Start line: 3167
		// Start offset: 0x800544F8
		// Variables:
	// 		struct _AadSequenceSlot *slot; // $a1
	// 		int track; // $a0
	/* end block 1 */
	// End offset: 0x80054560
	// End Line: 3181

	/* begin block 2 */
		// Start line: 7256
	/* end block 2 */
	// End Line: 7257

	/* begin block 3 */
		// Start line: 7257
	/* end block 3 */
	// End Line: 7258

	/* begin block 4 */
		// Start line: 7260
	/* end block 4 */
	// End Line: 7261

void aadResumeSlot(int slotNumber)

{
  int in_v1;
  
  *(ushort *)(in_v1 + 0x540) = *(ushort *)(in_v1 + 0x540) & 0xfffe;
  FUN_800545b0();
  return;
}



// decompiled code
// original method signature: 
// int /*$ra*/ aadGetSlotStatus(int slotNumber /*$a0*/)
 // line 3184, offset 0x80054568
	/* begin block 1 */
		// Start line: 7296
	/* end block 1 */
	// End Line: 7297

	/* begin block 2 */
		// Start line: 7297
	/* end block 2 */
	// End Line: 7298

int aadGetSlotStatus(int slotNumber)

{
  int in_v0;
  uint uVar1;
  byte in_v1;
  int in_a1;
  
  while( true ) {
    *(byte *)(in_v0 + 0x3d8) = in_v1;
    in_v0 = in_a1 + slotNumber;
    if (0xf < slotNumber) break;
    slotNumber = slotNumber + 1;
    in_v1 = *(byte *)(in_v0 + 0x3d8) | 0x20;
  }
  uVar1 = (uint)*(ushort *)(in_a1 + 0x540) | 1;
  *(undefined2 *)(in_a1 + 0x540) = (short)uVar1;
  return uVar1;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadAllNotesOff(int slotNumber /*$a0*/)
 // line 3210, offset 0x80054588
	/* begin block 1 */
		// Start line: 3212
		// Start offset: 0x80054588
		// Variables:
	// 		struct AadSynthVoice *voice; // $a0
	// 		unsigned long vmask; // $a1
	// 		int i; // $a3
	// 		struct _AadSequenceSlot *slot; // $t0
	/* end block 1 */
	// End offset: 0x80054620
	// End Line: 3235

	/* begin block 2 */
		// Start line: 6420
	/* end block 2 */
	// End Line: 6421

	/* begin block 3 */
		// Start line: 7324
	/* end block 3 */
	// End Line: 7325

	/* begin block 4 */
		// Start line: 7330
	/* end block 4 */
	// End Line: 7331

void aadAllNotesOff(int slotNumber)

{
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadMuteChannels(struct _AadSequenceSlot *slot /*$a0*/, unsigned long channelList /*$a1*/)
 // line 3252, offset 0x80054628
	/* begin block 1 */
		// Start line: 3254
		// Start offset: 0x80054628
		// Variables:
	// 		struct AadSynthVoice *voice; // $a2
	// 		unsigned long vmask; // $t2
	// 		unsigned long delayedMute; // $a2
	// 		int channel; // $t1
	// 		int i; // $t0
	/* end block 1 */
	// End offset: 0x800546FC
	// End Line: 3289

	/* begin block 2 */
		// Start line: 6504
	/* end block 2 */
	// End Line: 6505

	/* begin block 3 */
		// Start line: 7401
	/* end block 3 */
	// End Line: 7402

	/* begin block 4 */
		// Start line: 7406
	/* end block 4 */
	// End Line: 7407

void aadMuteChannels(_AadSequenceSlot *slot,ulong channelList)

{
  uint in_v1;
  
  slot->loopSequencePosition[0x37] =
       (_func_10 *)((uint)slot->loopSequencePosition[0x37] | channelList);
  slot->loopSequencePosition[0x38] = (_func_10 *)((uint)slot->loopSequencePosition[0x38] & in_v1);
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadUnMuteChannels(struct _AadSequenceSlot *slot /*$a0*/, unsigned long channelList /*$a1*/)
 // line 3292, offset 0x80054704
	/* begin block 1 */
		// Start line: 3294
		// Start offset: 0x80054704
		// Variables:
	// 		unsigned long delayedUnMute; // $a2
	/* end block 1 */
	// End offset: 0x80054728
	// End Line: 3302

	/* begin block 2 */
		// Start line: 7494
	/* end block 2 */
	// End Line: 7495

	/* begin block 3 */
		// Start line: 7495
	/* end block 3 */
	// End Line: 7496

	/* begin block 4 */
		// Start line: 7498
	/* end block 4 */
	// End Line: 7499

void aadUnMuteChannels(_AadSequenceSlot *slot,ulong channelList)

{
  uint in_v1;
  uint in_t2;
  
  slot->loopSequencePosition[0x37] = (_func_10 *)((uint)slot->loopSequencePosition[0x37] | in_t2);
  slot->loopSequencePosition[0x38] = (_func_10 *)((uint)slot->loopSequencePosition[0x38] & in_v1);
  return;
}



// decompiled code
// original method signature: 
// TDRFuncPtr_aadInstallEndSequenceCallback /*$ra*/ aadInstallEndSequenceCallback(TDRFuncPtr_aadInstallEndSequenceCallback0callbackProc callbackProc /*$a0*/, long data /*$a1*/)
 // line 3405, offset 0x8005473c
	/* begin block 1 */
		// Start line: 3407
		// Start offset: 0x8005473C
		// Variables:
	// 		void (*previousCallbackProc)(); // $v0
	/* end block 1 */
	// End offset: 0x8005473C
	// End Line: 3409

	/* begin block 2 */
		// Start line: 6810
	/* end block 2 */
	// End Line: 6811

	/* begin block 3 */
		// Start line: 7620
	/* end block 3 */
	// End Line: 7621

	/* begin block 4 */
		// Start line: 7622
	/* end block 4 */
	// End Line: 7623

TDRFuncPtr_aadInstallEndSequenceCallback
aadInstallEndSequenceCallback
          (TDRFuncPtr_aadInstallEndSequenceCallback0callbackProc callbackProc,long data)

{
  TDRFuncPtr_aadInstallEndSequenceCallback pTVar1;
  uint in_a2;
  
  *(ushort *)(callbackProc + 0x548) = *(ushort *)(callbackProc + 0x548) | (ushort)in_a2;
  pTVar1 = (TDRFuncPtr_aadInstallEndSequenceCallback)
           ((uint)*(ushort *)(callbackProc + 0x542) & ~(data & ~in_a2));
  *(short *)(callbackProc + 0x542) = (short)pTVar1;
  return pTVar1;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadSetUserVariable(int variableNumber /*$a0*/, int value /*$a1*/)
 // line 3416, offset 0x80054754
	/* begin block 1 */
		// Start line: 7641
	/* end block 1 */
	// End Line: 7642

	/* begin block 2 */
		// Start line: 7643
	/* end block 2 */
	// End Line: 7644

void aadSetUserVariable(int variableNumber,int value)

{
  ushort in_v0;
  
  *(ushort *)(variableNumber + 0x542) = in_v0 & ~(ushort)value;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadSetNoUpdateMode(int noUpdate /*$a0*/)
 // line 3446, offset 0x80054768
	/* begin block 1 */
		// Start line: 6892
	/* end block 1 */
	// End Line: 6893

	/* begin block 2 */
		// Start line: 7675
	/* end block 2 */
	// End Line: 7676

void aadSetNoUpdateMode(int noUpdate)

{
  int in_v1;
  undefined4 in_a1;
  
  *(int *)(&DAT_00001bfc + in_v1) = noUpdate;
  *(undefined4 *)(&DAT_00001c04 + in_v1) = in_a1;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadPauseSound()
 // line 3467, offset 0x800547a8
	/* begin block 1 */
		// Start line: 3468
		// Start offset: 0x800547A8
		// Variables:
	// 		int i; // $s0
	/* end block 1 */
	// End offset: 0x80054828
	// End Line: 3484

	/* begin block 2 */
		// Start line: 6934
	/* end block 2 */
	// End Line: 6935

	/* begin block 3 */
		// Start line: 7705
	/* end block 3 */
	// End Line: 7706

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadPauseSound(void)

{
  uint in_v0;
  int in_v1;
  
  *(uint *)(in_v1 + 0x24) = in_v0 | 2;
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadCancelPauseSound()
 // line 3486, offset 0x80054840
	/* begin block 1 */
		// Start line: 7755
	/* end block 1 */
	// End Line: 7756

	/* begin block 2 */
		// Start line: 7757
	/* end block 2 */
	// End Line: 7758

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadCancelPauseSound(void)

{
  int iVar1;
  int iVar2;
  int unaff_s0;
  int unaff_s1;
  int unaff_s2;
  
  while (unaff_s0 = unaff_s0 + 1, unaff_s0 < 0x18) {
    iVar2 = (int)&aadMem->updateCounter + unaff_s2;
    unaff_s2 = unaff_s2 + 2;
    iVar1 = (int)&aadMem->updateCounter + unaff_s1;
    unaff_s1 = unaff_s1 + 0x1c;
    *(ushort *)(iVar1 + 0x1ee) = *(ushort *)(iVar1 + 0x1ee) & 0xfffd;
    FUN_800bff48(unaff_s0,iVar2);
    FUN_800bff68(unaff_s0,0);
  }
  return;
}



// decompiled code
// original method signature: 
// void /*$ra*/ aadResumeSound()
 // line 3493, offset 0x8005485c
	/* begin block 1 */
		// Start line: 3494
		// Start offset: 0x8005485C
		// Variables:
	// 		int i; // $s0
	/* end block 1 */
	// End offset: 0x800548D4
	// End Line: 3509

	/* begin block 2 */
		// Start line: 7769
	/* end block 2 */
	// End Line: 7770

	/* begin block 3 */
		// Start line: 7773
	/* end block 3 */
	// End Line: 7774

/* WARNING: Unknown calling convention yet parameter storage is locked */

void aadResumeSound(void)

{
  return;
}





